{"ast":null,"code":"/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n// \"typed\", the Type Expression Parser for doctrine.\n(function () {\n  'use strict';\n\n  var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;\n  esutils = require('esutils');\n  utility = require('./utility');\n  Syntax = {\n    NullableLiteral: 'NullableLiteral',\n    AllLiteral: 'AllLiteral',\n    NullLiteral: 'NullLiteral',\n    UndefinedLiteral: 'UndefinedLiteral',\n    VoidLiteral: 'VoidLiteral',\n    UnionType: 'UnionType',\n    ArrayType: 'ArrayType',\n    RecordType: 'RecordType',\n    FieldType: 'FieldType',\n    FunctionType: 'FunctionType',\n    ParameterType: 'ParameterType',\n    RestType: 'RestType',\n    NonNullableType: 'NonNullableType',\n    OptionalType: 'OptionalType',\n    NullableType: 'NullableType',\n    NameExpression: 'NameExpression',\n    TypeApplication: 'TypeApplication',\n    StringLiteralType: 'StringLiteralType',\n    NumericLiteralType: 'NumericLiteralType',\n    BooleanLiteralType: 'BooleanLiteralType'\n  };\n  Token = {\n    ILLEGAL: 0,\n    // ILLEGAL\n    DOT_LT: 1,\n    // .<\n    REST: 2,\n    // ...\n    LT: 3,\n    // <\n    GT: 4,\n    // >\n    LPAREN: 5,\n    // (\n    RPAREN: 6,\n    // )\n    LBRACE: 7,\n    // {\n    RBRACE: 8,\n    // }\n    LBRACK: 9,\n    // [\n    RBRACK: 10,\n    // ]\n    COMMA: 11,\n    // ,\n    COLON: 12,\n    // :\n    STAR: 13,\n    // *\n    PIPE: 14,\n    // |\n    QUESTION: 15,\n    // ?\n    BANG: 16,\n    // !\n    EQUAL: 17,\n    // =\n    NAME: 18,\n    // name token\n    STRING: 19,\n    // string\n    NUMBER: 20,\n    // number\n    EOF: 21\n  };\n\n  function isTypeName(ch) {\n    return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n  }\n\n  function Context(previous, index, token, value) {\n    this._previous = previous;\n    this._index = index;\n    this._token = token;\n    this._value = value;\n  }\n\n  Context.prototype.restore = function () {\n    previous = this._previous;\n    index = this._index;\n    token = this._token;\n    value = this._value;\n  };\n\n  Context.save = function () {\n    return new Context(previous, index, token, value);\n  };\n\n  function maybeAddRange(node, range) {\n    if (addRange) {\n      node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n    }\n\n    return node;\n  }\n\n  function advance() {\n    var ch = source.charAt(index);\n    index += 1;\n    return ch;\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n        ch = advance();\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function scanString() {\n    var str = '',\n        quote,\n        ch,\n        code,\n        unescaped,\n        restore; //TODO review removal octal = false\n\n    quote = source.charAt(index);\n    ++index;\n\n    while (index < length) {\n      ch = advance();\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = advance();\n\n        if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\v';\n              break;\n\n            default:\n              if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                code = '01234567'.indexOf(ch); // \\0 is not octal escape sequence\n                // Deprecating unused code. TODO review removal\n                //if (code !== 0) {\n                //    octal = true;\n                //}\n\n                if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                  //TODO Review Removal octal = true;\n                  code = code * 8 + '01234567'.indexOf(advance()); // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n\n                  if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                    code = code * 8 + '01234567'.indexOf(advance());\n                  }\n                }\n\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          if (ch === '\\r' && source.charCodeAt(index) === 0x0A\n          /* '\\n' */\n          ) {\n            ++index;\n          }\n        }\n      } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      utility.throwError('unexpected quote');\n    }\n\n    value = str;\n    return Token.STRING;\n  }\n\n  function scanNumber() {\n    var number, ch;\n    number = '';\n    ch = source.charCodeAt(index);\n\n    if (ch !== 0x2E\n    /* '.' */\n    ) {\n      number = advance();\n      ch = source.charCodeAt(index);\n\n      if (number === '0') {\n        if (ch === 0x78\n        /* 'x' */\n        || ch === 0x58\n        /* 'X' */\n        ) {\n          number += advance();\n\n          while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (!esutils.code.isHexDigit(ch)) {\n              break;\n            }\n\n            number += advance();\n          }\n\n          if (number.length <= 2) {\n            // only 0x\n            utility.throwError('unexpected token');\n          }\n\n          if (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (esutils.code.isIdentifierStartES5(ch)) {\n              utility.throwError('unexpected token');\n            }\n          }\n\n          value = parseInt(number, 16);\n          return Token.NUMBER;\n        }\n\n        if (esutils.code.isOctalDigit(ch)) {\n          number += advance();\n\n          while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (!esutils.code.isOctalDigit(ch)) {\n              break;\n            }\n\n            number += advance();\n          }\n\n          if (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n              utility.throwError('unexpected token');\n            }\n          }\n\n          value = parseInt(number, 8);\n          return Token.NUMBER;\n        }\n\n        if (esutils.code.isDecimalDigit(ch)) {\n          utility.throwError('unexpected token');\n        }\n      }\n\n      while (index < length) {\n        ch = source.charCodeAt(index);\n\n        if (!esutils.code.isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += advance();\n      }\n    }\n\n    if (ch === 0x2E\n    /* '.' */\n    ) {\n      number += advance();\n\n      while (index < length) {\n        ch = source.charCodeAt(index);\n\n        if (!esutils.code.isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += advance();\n      }\n    }\n\n    if (ch === 0x65\n    /* 'e' */\n    || ch === 0x45\n    /* 'E' */\n    ) {\n      number += advance();\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x2B\n      /* '+' */\n      || ch === 0x2D\n      /* '-' */\n      ) {\n        number += advance();\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (esutils.code.isDecimalDigit(ch)) {\n        number += advance();\n\n        while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (!esutils.code.isDecimalDigit(ch)) {\n            break;\n          }\n\n          number += advance();\n        }\n      } else {\n        utility.throwError('unexpected token');\n      }\n    }\n\n    if (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (esutils.code.isIdentifierStartES5(ch)) {\n        utility.throwError('unexpected token');\n      }\n    }\n\n    value = parseFloat(number);\n    return Token.NUMBER;\n  }\n\n  function scanTypeName() {\n    var ch, ch2;\n    value = advance();\n\n    while (index < length && isTypeName(source.charCodeAt(index))) {\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x2E\n      /* '.' */\n      ) {\n        if (index + 1 >= length) {\n          return Token.ILLEGAL;\n        }\n\n        ch2 = source.charCodeAt(index + 1);\n\n        if (ch2 === 0x3C\n        /* '<' */\n        ) {\n          break;\n        }\n      }\n\n      value += advance();\n    }\n\n    return Token.NAME;\n  }\n\n  function next() {\n    var ch;\n    previous = index;\n\n    while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n      advance();\n    }\n\n    if (index >= length) {\n      token = Token.EOF;\n      return token;\n    }\n\n    ch = source.charCodeAt(index);\n\n    switch (ch) {\n      case 0x27:\n      /* ''' */\n\n      case 0x22:\n        /* '\"' */\n        token = scanString();\n        return token;\n\n      case 0x3A:\n        /* ':' */\n        advance();\n        token = Token.COLON;\n        return token;\n\n      case 0x2C:\n        /* ',' */\n        advance();\n        token = Token.COMMA;\n        return token;\n\n      case 0x28:\n        /* '(' */\n        advance();\n        token = Token.LPAREN;\n        return token;\n\n      case 0x29:\n        /* ')' */\n        advance();\n        token = Token.RPAREN;\n        return token;\n\n      case 0x5B:\n        /* '[' */\n        advance();\n        token = Token.LBRACK;\n        return token;\n\n      case 0x5D:\n        /* ']' */\n        advance();\n        token = Token.RBRACK;\n        return token;\n\n      case 0x7B:\n        /* '{' */\n        advance();\n        token = Token.LBRACE;\n        return token;\n\n      case 0x7D:\n        /* '}' */\n        advance();\n        token = Token.RBRACE;\n        return token;\n\n      case 0x2E:\n        /* '.' */\n        if (index + 1 < length) {\n          ch = source.charCodeAt(index + 1);\n\n          if (ch === 0x3C\n          /* '<' */\n          ) {\n            advance(); // '.'\n\n            advance(); // '<'\n\n            token = Token.DOT_LT;\n            return token;\n          }\n\n          if (ch === 0x2E\n          /* '.' */\n          && index + 2 < length && source.charCodeAt(index + 2) === 0x2E\n          /* '.' */\n          ) {\n            advance(); // '.'\n\n            advance(); // '.'\n\n            advance(); // '.'\n\n            token = Token.REST;\n            return token;\n          }\n\n          if (esutils.code.isDecimalDigit(ch)) {\n            token = scanNumber();\n            return token;\n          }\n        }\n\n        token = Token.ILLEGAL;\n        return token;\n\n      case 0x3C:\n        /* '<' */\n        advance();\n        token = Token.LT;\n        return token;\n\n      case 0x3E:\n        /* '>' */\n        advance();\n        token = Token.GT;\n        return token;\n\n      case 0x2A:\n        /* '*' */\n        advance();\n        token = Token.STAR;\n        return token;\n\n      case 0x7C:\n        /* '|' */\n        advance();\n        token = Token.PIPE;\n        return token;\n\n      case 0x3F:\n        /* '?' */\n        advance();\n        token = Token.QUESTION;\n        return token;\n\n      case 0x21:\n        /* '!' */\n        advance();\n        token = Token.BANG;\n        return token;\n\n      case 0x3D:\n        /* '=' */\n        advance();\n        token = Token.EQUAL;\n        return token;\n\n      case 0x2D:\n        /* '-' */\n        token = scanNumber();\n        return token;\n\n      default:\n        if (esutils.code.isDecimalDigit(ch)) {\n          token = scanNumber();\n          return token;\n        } // type string permits following case,\n        //\n        // namespace.module.MyClass\n        //\n        // this reduced 1 token TK_NAME\n\n\n        utility.assert(isTypeName(ch));\n        token = scanTypeName();\n        return token;\n    }\n  }\n\n  function consume(target, text) {\n    utility.assert(token === target, text || 'consumed token not matched');\n    next();\n  }\n\n  function expect(target, message) {\n    if (token !== target) {\n      utility.throwError(message || 'unexpected token');\n    }\n\n    next();\n  } // UnionType := '(' TypeUnionList ')'\n  //\n  // TypeUnionList :=\n  //     <<empty>>\n  //   | NonemptyTypeUnionList\n  //\n  // NonemptyTypeUnionList :=\n  //     TypeExpression\n  //   | TypeExpression '|' NonemptyTypeUnionList\n\n\n  function parseUnionType() {\n    var elements,\n        startIndex = index - 1;\n    consume(Token.LPAREN, 'UnionType should start with (');\n    elements = [];\n\n    if (token !== Token.RPAREN) {\n      while (true) {\n        elements.push(parseTypeExpression());\n\n        if (token === Token.RPAREN) {\n          break;\n        }\n\n        expect(Token.PIPE);\n      }\n    }\n\n    consume(Token.RPAREN, 'UnionType should end with )');\n    return maybeAddRange({\n      type: Syntax.UnionType,\n      elements: elements\n    }, [startIndex, previous]);\n  } // ArrayType := '[' ElementTypeList ']'\n  //\n  // ElementTypeList :=\n  //     <<empty>>\n  //  | TypeExpression\n  //  | '...' TypeExpression\n  //  | TypeExpression ',' ElementTypeList\n\n\n  function parseArrayType() {\n    var elements,\n        startIndex = index - 1,\n        restStartIndex;\n    consume(Token.LBRACK, 'ArrayType should start with [');\n    elements = [];\n\n    while (token !== Token.RBRACK) {\n      if (token === Token.REST) {\n        restStartIndex = index - 3;\n        consume(Token.REST);\n        elements.push(maybeAddRange({\n          type: Syntax.RestType,\n          expression: parseTypeExpression()\n        }, [restStartIndex, previous]));\n        break;\n      } else {\n        elements.push(parseTypeExpression());\n      }\n\n      if (token !== Token.RBRACK) {\n        expect(Token.COMMA);\n      }\n    }\n\n    expect(Token.RBRACK);\n    return maybeAddRange({\n      type: Syntax.ArrayType,\n      elements: elements\n    }, [startIndex, previous]);\n  }\n\n  function parseFieldName() {\n    var v = value;\n\n    if (token === Token.NAME || token === Token.STRING) {\n      next();\n      return v;\n    }\n\n    if (token === Token.NUMBER) {\n      consume(Token.NUMBER);\n      return String(v);\n    }\n\n    utility.throwError('unexpected token');\n  } // FieldType :=\n  //     FieldName\n  //   | FieldName ':' TypeExpression\n  //\n  // FieldName :=\n  //     NameExpression\n  //   | StringLiteral\n  //   | NumberLiteral\n  //   | ReservedIdentifier\n\n\n  function parseFieldType() {\n    var key,\n        rangeStart = previous;\n    key = parseFieldName();\n\n    if (token === Token.COLON) {\n      consume(Token.COLON);\n      return maybeAddRange({\n        type: Syntax.FieldType,\n        key: key,\n        value: parseTypeExpression()\n      }, [rangeStart, previous]);\n    }\n\n    return maybeAddRange({\n      type: Syntax.FieldType,\n      key: key,\n      value: null\n    }, [rangeStart, previous]);\n  } // RecordType := '{' FieldTypeList '}'\n  //\n  // FieldTypeList :=\n  //     <<empty>>\n  //   | FieldType\n  //   | FieldType ',' FieldTypeList\n\n\n  function parseRecordType() {\n    var fields,\n        rangeStart = index - 1,\n        rangeEnd;\n    consume(Token.LBRACE, 'RecordType should start with {');\n    fields = [];\n\n    if (token === Token.COMMA) {\n      consume(Token.COMMA);\n    } else {\n      while (token !== Token.RBRACE) {\n        fields.push(parseFieldType());\n\n        if (token !== Token.RBRACE) {\n          expect(Token.COMMA);\n        }\n      }\n    }\n\n    rangeEnd = index;\n    expect(Token.RBRACE);\n    return maybeAddRange({\n      type: Syntax.RecordType,\n      fields: fields\n    }, [rangeStart, rangeEnd]);\n  } // NameExpression :=\n  //    Identifier\n  //  | TagIdentifier ':' Identifier\n  //\n  // Tag identifier is one of \"module\", \"external\" or \"event\"\n  // Identifier is the same as Token.NAME, including any dots, something like\n  // namespace.module.MyClass\n\n\n  function parseNameExpression() {\n    var name = value,\n        rangeStart = index - name.length;\n    expect(Token.NAME);\n\n    if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {\n      consume(Token.COLON);\n      name += ':' + value;\n      expect(Token.NAME);\n    }\n\n    return maybeAddRange({\n      type: Syntax.NameExpression,\n      name: name\n    }, [rangeStart, previous]);\n  } // TypeExpressionList :=\n  //     TopLevelTypeExpression\n  //   | TopLevelTypeExpression ',' TypeExpressionList\n\n\n  function parseTypeExpressionList() {\n    var elements = [];\n    elements.push(parseTop());\n\n    while (token === Token.COMMA) {\n      consume(Token.COMMA);\n      elements.push(parseTop());\n    }\n\n    return elements;\n  } // TypeName :=\n  //     NameExpression\n  //   | NameExpression TypeApplication\n  //\n  // TypeApplication :=\n  //     '.<' TypeExpressionList '>'\n  //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n\n\n  function parseTypeName() {\n    var expr,\n        applications,\n        startIndex = index - value.length;\n    expr = parseNameExpression();\n\n    if (token === Token.DOT_LT || token === Token.LT) {\n      next();\n      applications = parseTypeExpressionList();\n      expect(Token.GT);\n      return maybeAddRange({\n        type: Syntax.TypeApplication,\n        expression: expr,\n        applications: applications\n      }, [startIndex, previous]);\n    }\n\n    return expr;\n  } // ResultType :=\n  //     <<empty>>\n  //   | ':' void\n  //   | ':' TypeExpression\n  //\n  // BNF is above\n  // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n\n\n  function parseResultType() {\n    consume(Token.COLON, 'ResultType should start with :');\n\n    if (token === Token.NAME && value === 'void') {\n      consume(Token.NAME);\n      return {\n        type: Syntax.VoidLiteral\n      };\n    }\n\n    return parseTypeExpression();\n  } // ParametersType :=\n  //     RestParameterType\n  //   | NonRestParametersType\n  //   | NonRestParametersType ',' RestParameterType\n  //\n  // RestParameterType :=\n  //     '...'\n  //     '...' Identifier\n  //\n  // NonRestParametersType :=\n  //     ParameterType ',' NonRestParametersType\n  //   | ParameterType\n  //   | OptionalParametersType\n  //\n  // OptionalParametersType :=\n  //     OptionalParameterType\n  //   | OptionalParameterType, OptionalParametersType\n  //\n  // OptionalParameterType := ParameterType=\n  //\n  // ParameterType := TypeExpression | Identifier ':' TypeExpression\n  //\n  // Identifier is \"new\" or \"this\"\n\n\n  function parseParametersType() {\n    var params = [],\n        optionalSequence = false,\n        expr,\n        rest = false,\n        startIndex,\n        restStartIndex = index - 3,\n        nameStartIndex;\n\n    while (token !== Token.RPAREN) {\n      if (token === Token.REST) {\n        // RestParameterType\n        consume(Token.REST);\n        rest = true;\n      }\n\n      startIndex = previous;\n      expr = parseTypeExpression();\n\n      if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n        nameStartIndex = previous - expr.name.length; // Identifier ':' TypeExpression\n\n        consume(Token.COLON);\n        expr = maybeAddRange({\n          type: Syntax.ParameterType,\n          name: expr.name,\n          expression: parseTypeExpression()\n        }, [nameStartIndex, previous]);\n      }\n\n      if (token === Token.EQUAL) {\n        consume(Token.EQUAL);\n        expr = maybeAddRange({\n          type: Syntax.OptionalType,\n          expression: expr\n        }, [startIndex, previous]);\n        optionalSequence = true;\n      } else {\n        if (optionalSequence) {\n          utility.throwError('unexpected token');\n        }\n      }\n\n      if (rest) {\n        expr = maybeAddRange({\n          type: Syntax.RestType,\n          expression: expr\n        }, [restStartIndex, previous]);\n      }\n\n      params.push(expr);\n\n      if (token !== Token.RPAREN) {\n        expect(Token.COMMA);\n      }\n    }\n\n    return params;\n  } // FunctionType := 'function' FunctionSignatureType\n  //\n  // FunctionSignatureType :=\n  //   | TypeParameters '(' ')' ResultType\n  //   | TypeParameters '(' ParametersType ')' ResultType\n  //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n  //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n\n\n  function parseFunctionType() {\n    var isNew,\n        thisBinding,\n        params,\n        result,\n        fnType,\n        startIndex = index - value.length;\n    utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n    consume(Token.NAME); // Google Closure Compiler is not implementing TypeParameters.\n    // So we do not. if we don't get '(', we see it as error.\n\n    expect(Token.LPAREN);\n    isNew = false;\n    params = [];\n    thisBinding = null;\n\n    if (token !== Token.RPAREN) {\n      // ParametersType or 'this'\n      if (token === Token.NAME && (value === 'this' || value === 'new')) {\n        // 'this' or 'new'\n        // 'new' is Closure Compiler extension\n        isNew = value === 'new';\n        consume(Token.NAME);\n        expect(Token.COLON);\n        thisBinding = parseTypeName();\n\n        if (token === Token.COMMA) {\n          consume(Token.COMMA);\n          params = parseParametersType();\n        }\n      } else {\n        params = parseParametersType();\n      }\n    }\n\n    expect(Token.RPAREN);\n    result = null;\n\n    if (token === Token.COLON) {\n      result = parseResultType();\n    }\n\n    fnType = maybeAddRange({\n      type: Syntax.FunctionType,\n      params: params,\n      result: result\n    }, [startIndex, previous]);\n\n    if (thisBinding) {\n      // avoid adding null 'new' and 'this' properties\n      fnType['this'] = thisBinding;\n\n      if (isNew) {\n        fnType['new'] = true;\n      }\n    }\n\n    return fnType;\n  } // BasicTypeExpression :=\n  //     '*'\n  //   | 'null'\n  //   | 'undefined'\n  //   | TypeName\n  //   | FunctionType\n  //   | UnionType\n  //   | RecordType\n  //   | ArrayType\n\n\n  function parseBasicTypeExpression() {\n    var context, startIndex;\n\n    switch (token) {\n      case Token.STAR:\n        consume(Token.STAR);\n        return maybeAddRange({\n          type: Syntax.AllLiteral\n        }, [previous - 1, previous]);\n\n      case Token.LPAREN:\n        return parseUnionType();\n\n      case Token.LBRACK:\n        return parseArrayType();\n\n      case Token.LBRACE:\n        return parseRecordType();\n\n      case Token.NAME:\n        startIndex = index - value.length;\n\n        if (value === 'null') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.NullLiteral\n          }, [startIndex, previous]);\n        }\n\n        if (value === 'undefined') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.UndefinedLiteral\n          }, [startIndex, previous]);\n        }\n\n        if (value === 'true' || value === 'false') {\n          consume(Token.NAME);\n          return maybeAddRange({\n            type: Syntax.BooleanLiteralType,\n            value: value === 'true'\n          }, [startIndex, previous]);\n        }\n\n        context = Context.save();\n\n        if (value === 'function') {\n          try {\n            return parseFunctionType();\n          } catch (e) {\n            context.restore();\n          }\n        }\n\n        return parseTypeName();\n\n      case Token.STRING:\n        next();\n        return maybeAddRange({\n          type: Syntax.StringLiteralType,\n          value: value\n        }, [previous - value.length - 2, previous]);\n\n      case Token.NUMBER:\n        next();\n        return maybeAddRange({\n          type: Syntax.NumericLiteralType,\n          value: value\n        }, [previous - String(value).length, previous]);\n\n      default:\n        utility.throwError('unexpected token');\n    }\n  } // TypeExpression :=\n  //     BasicTypeExpression\n  //   | '?' BasicTypeExpression\n  //   | '!' BasicTypeExpression\n  //   | BasicTypeExpression '?'\n  //   | BasicTypeExpression '!'\n  //   | '?'\n  //   | BasicTypeExpression '[]'\n\n\n  function parseTypeExpression() {\n    var expr, rangeStart;\n\n    if (token === Token.QUESTION) {\n      rangeStart = index - 1;\n      consume(Token.QUESTION);\n\n      if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {\n        return maybeAddRange({\n          type: Syntax.NullableLiteral\n        }, [rangeStart, previous]);\n      }\n\n      return maybeAddRange({\n        type: Syntax.NullableType,\n        expression: parseBasicTypeExpression(),\n        prefix: true\n      }, [rangeStart, previous]);\n    } else if (token === Token.BANG) {\n      rangeStart = index - 1;\n      consume(Token.BANG);\n      return maybeAddRange({\n        type: Syntax.NonNullableType,\n        expression: parseBasicTypeExpression(),\n        prefix: true\n      }, [rangeStart, previous]);\n    } else {\n      rangeStart = previous;\n    }\n\n    expr = parseBasicTypeExpression();\n\n    if (token === Token.BANG) {\n      consume(Token.BANG);\n      return maybeAddRange({\n        type: Syntax.NonNullableType,\n        expression: expr,\n        prefix: false\n      }, [rangeStart, previous]);\n    }\n\n    if (token === Token.QUESTION) {\n      consume(Token.QUESTION);\n      return maybeAddRange({\n        type: Syntax.NullableType,\n        expression: expr,\n        prefix: false\n      }, [rangeStart, previous]);\n    }\n\n    if (token === Token.LBRACK) {\n      consume(Token.LBRACK);\n      expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n      return maybeAddRange({\n        type: Syntax.TypeApplication,\n        expression: maybeAddRange({\n          type: Syntax.NameExpression,\n          name: 'Array'\n        }, [rangeStart, previous]),\n        applications: [expr]\n      }, [rangeStart, previous]);\n    }\n\n    return expr;\n  } // TopLevelTypeExpression :=\n  //      TypeExpression\n  //    | TypeUnionList\n  //\n  // This rule is Google Closure Compiler extension, not ES4\n  // like,\n  //   { number | string }\n  // If strict to ES4, we should write it as\n  //   { (number|string) }\n\n\n  function parseTop() {\n    var expr, elements;\n    expr = parseTypeExpression();\n\n    if (token !== Token.PIPE) {\n      return expr;\n    }\n\n    elements = [expr];\n    consume(Token.PIPE);\n\n    while (true) {\n      elements.push(parseTypeExpression());\n\n      if (token !== Token.PIPE) {\n        break;\n      }\n\n      consume(Token.PIPE);\n    }\n\n    return maybeAddRange({\n      type: Syntax.UnionType,\n      elements: elements\n    }, [0, index]);\n  }\n\n  function parseTopParamType() {\n    var expr;\n\n    if (token === Token.REST) {\n      consume(Token.REST);\n      return maybeAddRange({\n        type: Syntax.RestType,\n        expression: parseTop()\n      }, [0, index]);\n    }\n\n    expr = parseTop();\n\n    if (token === Token.EQUAL) {\n      consume(Token.EQUAL);\n      return maybeAddRange({\n        type: Syntax.OptionalType,\n        expression: expr\n      }, [0, index]);\n    }\n\n    return expr;\n  }\n\n  function parseType(src, opt) {\n    var expr;\n    source = src;\n    length = source.length;\n    index = 0;\n    previous = 0;\n    addRange = opt && opt.range;\n    rangeOffset = opt && opt.startIndex || 0;\n    next();\n    expr = parseTop();\n\n    if (opt && opt.midstream) {\n      return {\n        expression: expr,\n        index: previous\n      };\n    }\n\n    if (token !== Token.EOF) {\n      utility.throwError('not reach to EOF');\n    }\n\n    return expr;\n  }\n\n  function parseParamType(src, opt) {\n    var expr;\n    source = src;\n    length = source.length;\n    index = 0;\n    previous = 0;\n    addRange = opt && opt.range;\n    rangeOffset = opt && opt.startIndex || 0;\n    next();\n    expr = parseTopParamType();\n\n    if (opt && opt.midstream) {\n      return {\n        expression: expr,\n        index: previous\n      };\n    }\n\n    if (token !== Token.EOF) {\n      utility.throwError('not reach to EOF');\n    }\n\n    return expr;\n  }\n\n  function stringifyImpl(node, compact, topLevel) {\n    var result, i, iz;\n\n    switch (node.type) {\n      case Syntax.NullableLiteral:\n        result = '?';\n        break;\n\n      case Syntax.AllLiteral:\n        result = '*';\n        break;\n\n      case Syntax.NullLiteral:\n        result = 'null';\n        break;\n\n      case Syntax.UndefinedLiteral:\n        result = 'undefined';\n        break;\n\n      case Syntax.VoidLiteral:\n        result = 'void';\n        break;\n\n      case Syntax.UnionType:\n        if (!topLevel) {\n          result = '(';\n        } else {\n          result = '';\n        }\n\n        for (i = 0, iz = node.elements.length; i < iz; ++i) {\n          result += stringifyImpl(node.elements[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? '|' : ' | ';\n          }\n        }\n\n        if (!topLevel) {\n          result += ')';\n        }\n\n        break;\n\n      case Syntax.ArrayType:\n        result = '[';\n\n        for (i = 0, iz = node.elements.length; i < iz; ++i) {\n          result += stringifyImpl(node.elements[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += ']';\n        break;\n\n      case Syntax.RecordType:\n        result = '{';\n\n        for (i = 0, iz = node.fields.length; i < iz; ++i) {\n          result += stringifyImpl(node.fields[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += '}';\n        break;\n\n      case Syntax.FieldType:\n        if (node.value) {\n          result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n        } else {\n          result = node.key;\n        }\n\n        break;\n\n      case Syntax.FunctionType:\n        result = compact ? 'function(' : 'function (';\n\n        if (node['this']) {\n          if (node['new']) {\n            result += compact ? 'new:' : 'new: ';\n          } else {\n            result += compact ? 'this:' : 'this: ';\n          }\n\n          result += stringifyImpl(node['this'], compact);\n\n          if (node.params.length !== 0) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        for (i = 0, iz = node.params.length; i < iz; ++i) {\n          result += stringifyImpl(node.params[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += ')';\n\n        if (node.result) {\n          result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n        }\n\n        break;\n\n      case Syntax.ParameterType:\n        result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n        break;\n\n      case Syntax.RestType:\n        result = '...';\n\n        if (node.expression) {\n          result += stringifyImpl(node.expression, compact);\n        }\n\n        break;\n\n      case Syntax.NonNullableType:\n        if (node.prefix) {\n          result = '!' + stringifyImpl(node.expression, compact);\n        } else {\n          result = stringifyImpl(node.expression, compact) + '!';\n        }\n\n        break;\n\n      case Syntax.OptionalType:\n        result = stringifyImpl(node.expression, compact) + '=';\n        break;\n\n      case Syntax.NullableType:\n        if (node.prefix) {\n          result = '?' + stringifyImpl(node.expression, compact);\n        } else {\n          result = stringifyImpl(node.expression, compact) + '?';\n        }\n\n        break;\n\n      case Syntax.NameExpression:\n        result = node.name;\n        break;\n\n      case Syntax.TypeApplication:\n        result = stringifyImpl(node.expression, compact) + '.<';\n\n        for (i = 0, iz = node.applications.length; i < iz; ++i) {\n          result += stringifyImpl(node.applications[i], compact);\n\n          if (i + 1 !== iz) {\n            result += compact ? ',' : ', ';\n          }\n        }\n\n        result += '>';\n        break;\n\n      case Syntax.StringLiteralType:\n        result = '\"' + node.value + '\"';\n        break;\n\n      case Syntax.NumericLiteralType:\n        result = String(node.value);\n        break;\n\n      case Syntax.BooleanLiteralType:\n        result = String(node.value);\n        break;\n\n      default:\n        utility.throwError('Unknown type ' + node.type);\n    }\n\n    return result;\n  }\n\n  function stringify(node, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    return stringifyImpl(node, options.compact, options.topLevel);\n  }\n\n  exports.parseType = parseType;\n  exports.parseParamType = parseParamType;\n  exports.stringify = stringify;\n  exports.Syntax = Syntax;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/Users/anhadparashar/Desktop/stuFF/PROGRAMMMING/ReactJs/utilities/node_modules/doctrine/lib/typed.js"],"names":["Syntax","Token","source","length","index","previous","token","value","esutils","utility","rangeOffset","addRange","require","NullableLiteral","AllLiteral","NullLiteral","UndefinedLiteral","VoidLiteral","UnionType","ArrayType","RecordType","FieldType","FunctionType","ParameterType","RestType","NonNullableType","OptionalType","NullableType","NameExpression","TypeApplication","StringLiteralType","NumericLiteralType","BooleanLiteralType","ILLEGAL","DOT_LT","REST","LT","GT","LPAREN","RPAREN","LBRACE","RBRACE","LBRACK","RBRACK","COMMA","COLON","STAR","PIPE","QUESTION","BANG","EQUAL","NAME","STRING","NUMBER","EOF","isTypeName","ch","indexOf","String","fromCharCode","code","isWhiteSpace","isLineTerminator","Context","_previous","_index","_token","_value","prototype","restore","save","maybeAddRange","node","range","advance","charAt","scanHexEscape","prefix","i","len","isHexDigit","charCodeAt","toLowerCase","scanString","str","quote","unescaped","isOctalDigit","throwError","scanNumber","number","isIdentifierStartES5","parseInt","isDecimalDigit","parseFloat","scanTypeName","ch2","next","assert","consume","target","text","expect","message","parseUnionType","elements","startIndex","push","parseTypeExpression","type","parseArrayType","restStartIndex","expression","parseFieldName","v","parseFieldType","key","rangeStart","parseRecordType","fields","rangeEnd","parseNameExpression","name","parseTypeExpressionList","parseTop","parseTypeName","expr","applications","parseResultType","parseParametersType","params","optionalSequence","rest","nameStartIndex","parseFunctionType","isNew","thisBinding","result","fnType","parseBasicTypeExpression","context","e","parseTopParamType","parseType","src","opt","midstream","parseParamType","stringifyImpl","compact","topLevel","iz","stringify","options","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEC,aAAY;AACT;;AAEA,MAAIA,MAAJ,EACIC,KADJ,EAEIC,MAFJ,EAGIC,MAHJ,EAIIC,KAJJ,EAKIC,QALJ,EAMIC,KANJ,EAOIC,KAPJ,EAQIC,OARJ,EASIC,OATJ,EAUIC,WAVJ,EAWIC,QAXJ;AAaAH,EAAAA,OAAO,GAAGI,OAAO,CAAC,SAAD,CAAjB;AACAH,EAAAA,OAAO,GAAGG,OAAO,CAAC,WAAD,CAAjB;AAEAZ,EAAAA,MAAM,GAAG;AACLa,IAAAA,eAAe,EAAE,iBADZ;AAELC,IAAAA,UAAU,EAAE,YAFP;AAGLC,IAAAA,WAAW,EAAE,aAHR;AAILC,IAAAA,gBAAgB,EAAE,kBAJb;AAKLC,IAAAA,WAAW,EAAE,aALR;AAMLC,IAAAA,SAAS,EAAE,WANN;AAOLC,IAAAA,SAAS,EAAE,WAPN;AAQLC,IAAAA,UAAU,EAAE,YARP;AASLC,IAAAA,SAAS,EAAE,WATN;AAULC,IAAAA,YAAY,EAAE,cAVT;AAWLC,IAAAA,aAAa,EAAE,eAXV;AAYLC,IAAAA,QAAQ,EAAE,UAZL;AAaLC,IAAAA,eAAe,EAAE,iBAbZ;AAcLC,IAAAA,YAAY,EAAE,cAdT;AAeLC,IAAAA,YAAY,EAAE,cAfT;AAgBLC,IAAAA,cAAc,EAAE,gBAhBX;AAiBLC,IAAAA,eAAe,EAAE,iBAjBZ;AAkBLC,IAAAA,iBAAiB,EAAE,mBAlBd;AAmBLC,IAAAA,kBAAkB,EAAE,oBAnBf;AAoBLC,IAAAA,kBAAkB,EAAE;AApBf,GAAT;AAuBA/B,EAAAA,KAAK,GAAG;AACJgC,IAAAA,OAAO,EAAE,CADL;AACW;AACfC,IAAAA,MAAM,EAAE,CAFJ;AAEW;AACfC,IAAAA,IAAI,EAAE,CAHF;AAGW;AACfC,IAAAA,EAAE,EAAE,CAJA;AAIW;AACfC,IAAAA,EAAE,EAAE,CALA;AAKW;AACfC,IAAAA,MAAM,EAAE,CANJ;AAMW;AACfC,IAAAA,MAAM,EAAE,CAPJ;AAOW;AACfC,IAAAA,MAAM,EAAE,CARJ;AAQW;AACfC,IAAAA,MAAM,EAAE,CATJ;AASW;AACfC,IAAAA,MAAM,EAAE,CAVJ;AAUU;AACdC,IAAAA,MAAM,EAAE,EAXJ;AAWW;AACfC,IAAAA,KAAK,EAAE,EAZH;AAYW;AACfC,IAAAA,KAAK,EAAE,EAbH;AAaW;AACfC,IAAAA,IAAI,EAAE,EAdF;AAcW;AACfC,IAAAA,IAAI,EAAE,EAfF;AAeW;AACfC,IAAAA,QAAQ,EAAE,EAhBN;AAgBW;AACfC,IAAAA,IAAI,EAAE,EAjBF;AAiBW;AACfC,IAAAA,KAAK,EAAE,EAlBH;AAkBW;AACfC,IAAAA,IAAI,EAAE,EAnBF;AAmBW;AACfC,IAAAA,MAAM,EAAE,EApBJ;AAoBW;AACfC,IAAAA,MAAM,EAAE,EArBJ;AAqBW;AACfC,IAAAA,GAAG,EAAE;AAtBD,GAAR;;AAyBA,WAASC,UAAT,CAAoBC,EAApB,EAAwB;AACpB,WAAO,kBAAkBC,OAAlB,CAA0BC,MAAM,CAACC,YAAP,CAAoBH,EAApB,CAA1B,MAAuD,CAAC,CAAxD,IAA6D,CAAChD,OAAO,CAACoD,IAAR,CAAaC,YAAb,CAA0BL,EAA1B,CAA9D,IAA+F,CAAChD,OAAO,CAACoD,IAAR,CAAaE,gBAAb,CAA8BN,EAA9B,CAAvG;AACH;;AAED,WAASO,OAAT,CAAiB1D,QAAjB,EAA2BD,KAA3B,EAAkCE,KAAlC,EAAyCC,KAAzC,EAAgD;AAC5C,SAAKyD,SAAL,GAAiB3D,QAAjB;AACA,SAAK4D,MAAL,GAAc7D,KAAd;AACA,SAAK8D,MAAL,GAAc5D,KAAd;AACA,SAAK6D,MAAL,GAAc5D,KAAd;AACH;;AAEDwD,EAAAA,OAAO,CAACK,SAAR,CAAkBC,OAAlB,GAA4B,YAAY;AACpChE,IAAAA,QAAQ,GAAG,KAAK2D,SAAhB;AACA5D,IAAAA,KAAK,GAAG,KAAK6D,MAAb;AACA3D,IAAAA,KAAK,GAAG,KAAK4D,MAAb;AACA3D,IAAAA,KAAK,GAAG,KAAK4D,MAAb;AACH,GALD;;AAOAJ,EAAAA,OAAO,CAACO,IAAR,GAAe,YAAY;AACvB,WAAO,IAAIP,OAAJ,CAAY1D,QAAZ,EAAsBD,KAAtB,EAA6BE,KAA7B,EAAoCC,KAApC,CAAP;AACH,GAFD;;AAIA,WAASgE,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAoC;AAChC,QAAI9D,QAAJ,EAAc;AACV6D,MAAAA,IAAI,CAACC,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAL,GAAW/D,WAAZ,EAAyB+D,KAAK,CAAC,CAAD,CAAL,GAAW/D,WAApC,CAAb;AACH;;AACD,WAAO8D,IAAP;AACH;;AAED,WAASE,OAAT,GAAmB;AACf,QAAIlB,EAAE,GAAGtD,MAAM,CAACyE,MAAP,CAAcvE,KAAd,CAAT;AACAA,IAAAA,KAAK,IAAI,CAAT;AACA,WAAOoD,EAAP;AACH;;AAED,WAASoB,aAAT,CAAuBC,MAAvB,EAA+B;AAC3B,QAAIC,CAAJ;AAAA,QAAOC,GAAP;AAAA,QAAYvB,EAAZ;AAAA,QAAgBI,IAAI,GAAG,CAAvB;AAEAmB,IAAAA,GAAG,GAAIF,MAAM,KAAK,GAAZ,GAAmB,CAAnB,GAAuB,CAA7B;;AACA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,GAAhB,EAAqB,EAAED,CAAvB,EAA0B;AACtB,UAAI1E,KAAK,GAAGD,MAAR,IAAkBK,OAAO,CAACoD,IAAR,CAAaoB,UAAb,CAAwB9E,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAxB,CAAtB,EAAyE;AACrEoD,QAAAA,EAAE,GAAGkB,OAAO,EAAZ;AACAd,QAAAA,IAAI,GAAGA,IAAI,GAAG,EAAP,GAAY,mBAAmBH,OAAnB,CAA2BD,EAAE,CAAC0B,WAAH,EAA3B,CAAnB;AACH,OAHD,MAGO;AACH,eAAO,EAAP;AACH;AACJ;;AACD,WAAOxB,MAAM,CAACC,YAAP,CAAoBC,IAApB,CAAP;AACH;;AAED,WAASuB,UAAT,GAAsB;AAClB,QAAIC,GAAG,GAAG,EAAV;AAAA,QAAcC,KAAd;AAAA,QAAqB7B,EAArB;AAAA,QAAyBI,IAAzB;AAAA,QAA+B0B,SAA/B;AAAA,QAA0CjB,OAA1C,CADkB,CACiC;;AACnDgB,IAAAA,KAAK,GAAGnF,MAAM,CAACyE,MAAP,CAAcvE,KAAd,CAAR;AACA,MAAEA,KAAF;;AAEA,WAAOA,KAAK,GAAGD,MAAf,EAAuB;AACnBqD,MAAAA,EAAE,GAAGkB,OAAO,EAAZ;;AAEA,UAAIlB,EAAE,KAAK6B,KAAX,EAAkB;AACdA,QAAAA,KAAK,GAAG,EAAR;AACA;AACH,OAHD,MAGO,IAAI7B,EAAE,KAAK,IAAX,EAAiB;AACpBA,QAAAA,EAAE,GAAGkB,OAAO,EAAZ;;AACA,YAAI,CAAClE,OAAO,CAACoD,IAAR,CAAaE,gBAAb,CAA8BN,EAAE,CAACyB,UAAH,CAAc,CAAd,CAA9B,CAAL,EAAsD;AAClD,kBAAQzB,EAAR;AACA,iBAAK,GAAL;AACI4B,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACA,iBAAK,GAAL;AACIf,cAAAA,OAAO,GAAGjE,KAAV;AACAkF,cAAAA,SAAS,GAAGV,aAAa,CAACpB,EAAD,CAAzB;;AACA,kBAAI8B,SAAJ,EAAe;AACXF,gBAAAA,GAAG,IAAIE,SAAP;AACH,eAFD,MAEO;AACHlF,gBAAAA,KAAK,GAAGiE,OAAR;AACAe,gBAAAA,GAAG,IAAI5B,EAAP;AACH;;AACD;;AACJ,iBAAK,GAAL;AACI4B,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACJ,iBAAK,GAAL;AACIA,cAAAA,GAAG,IAAI,IAAP;AACA;;AAEJ;AACI,kBAAI5E,OAAO,CAACoD,IAAR,CAAa2B,YAAb,CAA0B/B,EAAE,CAACyB,UAAH,CAAc,CAAd,CAA1B,CAAJ,EAAiD;AAC7CrB,gBAAAA,IAAI,GAAG,WAAWH,OAAX,CAAmBD,EAAnB,CAAP,CAD6C,CAG7C;AACA;AACA;AACA;AACA;;AAEA,oBAAIpD,KAAK,GAAGD,MAAR,IAAkBK,OAAO,CAACoD,IAAR,CAAa2B,YAAb,CAA0BrF,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAA1B,CAAtB,EAA2E;AACvE;AACAwD,kBAAAA,IAAI,GAAGA,IAAI,GAAG,CAAP,GAAW,WAAWH,OAAX,CAAmBiB,OAAO,EAA1B,CAAlB,CAFuE,CAIvE;AACA;;AACA,sBAAI,OAAOjB,OAAP,CAAeD,EAAf,KAAsB,CAAtB,IACIpD,KAAK,GAAGD,MADZ,IAEIK,OAAO,CAACoD,IAAR,CAAa2B,YAAb,CAA0BrF,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAA1B,CAFR,EAE6D;AACzDwD,oBAAAA,IAAI,GAAGA,IAAI,GAAG,CAAP,GAAW,WAAWH,OAAX,CAAmBiB,OAAO,EAA1B,CAAlB;AACH;AACJ;;AACDU,gBAAAA,GAAG,IAAI1B,MAAM,CAACC,YAAP,CAAoBC,IAApB,CAAP;AACH,eAtBD,MAsBO;AACHwB,gBAAAA,GAAG,IAAI5B,EAAP;AACH;;AACD;AAzDJ;AA2DH,SA5DD,MA4DO;AACH,cAAIA,EAAE,KAAM,IAAR,IAAgBtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,MAA6B;AAAM;AAAvD,YAAmE;AAC/D,cAAEA,KAAF;AACH;AACJ;AACJ,OAnEM,MAmEA,IAAII,OAAO,CAACoD,IAAR,CAAaE,gBAAb,CAA8BN,EAAE,CAACyB,UAAH,CAAc,CAAd,CAA9B,CAAJ,EAAqD;AACxD;AACH,OAFM,MAEA;AACHG,QAAAA,GAAG,IAAI5B,EAAP;AACH;AACJ;;AAED,QAAI6B,KAAK,KAAK,EAAd,EAAkB;AACd5E,MAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;;AAEDjF,IAAAA,KAAK,GAAG6E,GAAR;AACA,WAAOnF,KAAK,CAACmD,MAAb;AACH;;AAED,WAASqC,UAAT,GAAsB;AAClB,QAAIC,MAAJ,EAAYlC,EAAZ;AAEAkC,IAAAA,MAAM,GAAG,EAAT;AACAlC,IAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AAEA,QAAIoD,EAAE,KAAK;AAAM;AAAjB,MAA4B;AACxBkC,MAAAA,MAAM,GAAGhB,OAAO,EAAhB;AACAlB,MAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AAEA,UAAIsF,MAAM,KAAK,GAAf,EAAoB;AAChB,YAAIlC,EAAE,KAAK;AAAM;AAAb,WAA0BA,EAAE,KAAK;AAAM;AAA3C,UAAsD;AAClDkC,UAAAA,MAAM,IAAIhB,OAAO,EAAjB;;AACA,iBAAOtE,KAAK,GAAGD,MAAf,EAAuB;AACnBqD,YAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,gBAAI,CAACI,OAAO,CAACoD,IAAR,CAAaoB,UAAb,CAAwBxB,EAAxB,CAAL,EAAkC;AAC9B;AACH;;AACDkC,YAAAA,MAAM,IAAIhB,OAAO,EAAjB;AACH;;AAED,cAAIgB,MAAM,CAACvF,MAAP,IAAiB,CAArB,EAAwB;AACpB;AACAM,YAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;;AAED,cAAIpF,KAAK,GAAGD,MAAZ,EAAoB;AAChBqD,YAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,gBAAII,OAAO,CAACoD,IAAR,CAAa+B,oBAAb,CAAkCnC,EAAlC,CAAJ,EAA2C;AACvC/C,cAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;AACJ;;AACDjF,UAAAA,KAAK,GAAGqF,QAAQ,CAACF,MAAD,EAAS,EAAT,CAAhB;AACA,iBAAOzF,KAAK,CAACoD,MAAb;AACH;;AAED,YAAI7C,OAAO,CAACoD,IAAR,CAAa2B,YAAb,CAA0B/B,EAA1B,CAAJ,EAAmC;AAC/BkC,UAAAA,MAAM,IAAIhB,OAAO,EAAjB;;AACA,iBAAOtE,KAAK,GAAGD,MAAf,EAAuB;AACnBqD,YAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,gBAAI,CAACI,OAAO,CAACoD,IAAR,CAAa2B,YAAb,CAA0B/B,EAA1B,CAAL,EAAoC;AAChC;AACH;;AACDkC,YAAAA,MAAM,IAAIhB,OAAO,EAAjB;AACH;;AAED,cAAItE,KAAK,GAAGD,MAAZ,EAAoB;AAChBqD,YAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,gBAAII,OAAO,CAACoD,IAAR,CAAa+B,oBAAb,CAAkCnC,EAAlC,KAAyChD,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAA7C,EAA8E;AAC1E/C,cAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;AACJ;;AACDjF,UAAAA,KAAK,GAAGqF,QAAQ,CAACF,MAAD,EAAS,CAAT,CAAhB;AACA,iBAAOzF,KAAK,CAACoD,MAAb;AACH;;AAED,YAAI7C,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAJ,EAAqC;AACjC/C,UAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;AACJ;;AAED,aAAOpF,KAAK,GAAGD,MAAf,EAAuB;AACnBqD,QAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,YAAI,CAACI,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAL,EAAsC;AAClC;AACH;;AACDkC,QAAAA,MAAM,IAAIhB,OAAO,EAAjB;AACH;AACJ;;AAED,QAAIlB,EAAE,KAAK;AAAM;AAAjB,MAA4B;AACxBkC,MAAAA,MAAM,IAAIhB,OAAO,EAAjB;;AACA,aAAOtE,KAAK,GAAGD,MAAf,EAAuB;AACnBqD,QAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,YAAI,CAACI,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAL,EAAsC;AAClC;AACH;;AACDkC,QAAAA,MAAM,IAAIhB,OAAO,EAAjB;AACH;AACJ;;AAED,QAAIlB,EAAE,KAAK;AAAM;AAAb,OAA0BA,EAAE,KAAK;AAAM;AAA3C,MAAsD;AAClDkC,MAAAA,MAAM,IAAIhB,OAAO,EAAjB;AAEAlB,MAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,UAAIoD,EAAE,KAAK;AAAM;AAAb,SAA0BA,EAAE,KAAK;AAAM;AAA3C,QAAsD;AAClDkC,QAAAA,MAAM,IAAIhB,OAAO,EAAjB;AACH;;AAEDlB,MAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,UAAII,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAJ,EAAqC;AACjCkC,QAAAA,MAAM,IAAIhB,OAAO,EAAjB;;AACA,eAAOtE,KAAK,GAAGD,MAAf,EAAuB;AACnBqD,UAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,cAAI,CAACI,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAL,EAAsC;AAClC;AACH;;AACDkC,UAAAA,MAAM,IAAIhB,OAAO,EAAjB;AACH;AACJ,OATD,MASO;AACHjE,QAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;AACJ;;AAED,QAAIpF,KAAK,GAAGD,MAAZ,EAAoB;AAChBqD,MAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,UAAII,OAAO,CAACoD,IAAR,CAAa+B,oBAAb,CAAkCnC,EAAlC,CAAJ,EAA2C;AACvC/C,QAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;AACJ;;AAEDjF,IAAAA,KAAK,GAAGuF,UAAU,CAACJ,MAAD,CAAlB;AACA,WAAOzF,KAAK,CAACoD,MAAb;AACH;;AAGD,WAAS0C,YAAT,GAAwB;AACpB,QAAIvC,EAAJ,EAAQwC,GAAR;AAEAzF,IAAAA,KAAK,GAAGmE,OAAO,EAAf;;AACA,WAAOtE,KAAK,GAAGD,MAAR,IAAkBoD,UAAU,CAACrD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAD,CAAnC,EAA+D;AAC3DoD,MAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,UAAIoD,EAAE,KAAK;AAAM;AAAjB,QAA4B;AACxB,YAAKpD,KAAK,GAAG,CAAT,IAAeD,MAAnB,EAA2B;AACvB,iBAAOF,KAAK,CAACgC,OAAb;AACH;;AACD+D,QAAAA,GAAG,GAAG9F,MAAM,CAAC+E,UAAP,CAAkB7E,KAAK,GAAG,CAA1B,CAAN;;AACA,YAAI4F,GAAG,KAAK;AAAM;AAAlB,UAA6B;AACzB;AACH;AACJ;;AACDzF,MAAAA,KAAK,IAAImE,OAAO,EAAhB;AACH;;AACD,WAAOzE,KAAK,CAACkD,IAAb;AACH;;AAED,WAAS8C,IAAT,GAAgB;AACZ,QAAIzC,EAAJ;AAEAnD,IAAAA,QAAQ,GAAGD,KAAX;;AAEA,WAAOA,KAAK,GAAGD,MAAR,IAAkBK,OAAO,CAACoD,IAAR,CAAaC,YAAb,CAA0B3D,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAA1B,CAAzB,EAA8E;AAC1EsE,MAAAA,OAAO;AACV;;AACD,QAAItE,KAAK,IAAID,MAAb,EAAqB;AACjBG,MAAAA,KAAK,GAAGL,KAAK,CAACqD,GAAd;AACA,aAAOhD,KAAP;AACH;;AAEDkD,IAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAlB,CAAL;;AACA,YAAQoD,EAAR;AACA,WAAK,IAAL;AAAY;;AACZ,WAAK,IAAL;AAAY;AACRlD,QAAAA,KAAK,GAAG6E,UAAU,EAAlB;AACA,eAAO7E,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAAC4C,KAAd;AACA,eAAOvC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAAC2C,KAAd;AACA,eAAOtC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACqC,MAAd;AACA,eAAOhC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACsC,MAAd;AACA,eAAOjC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACyC,MAAd;AACA,eAAOpC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAAC0C,MAAd;AACA,eAAOrC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACuC,MAAd;AACA,eAAOlC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACwC,MAAd;AACA,eAAOnC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACR,YAAIF,KAAK,GAAG,CAAR,GAAYD,MAAhB,EAAwB;AACpBqD,UAAAA,EAAE,GAAGtD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAK,GAAG,CAA1B,CAAL;;AACA,cAAIoD,EAAE,KAAK;AAAM;AAAjB,YAA4B;AACxBkB,YAAAA,OAAO,GADiB,CACZ;;AACZA,YAAAA,OAAO,GAFiB,CAEZ;;AACZpE,YAAAA,KAAK,GAAGL,KAAK,CAACiC,MAAd;AACA,mBAAO5B,KAAP;AACH;;AAED,cAAIkD,EAAE,KAAK;AAAM;AAAb,aAA0BpD,KAAK,GAAG,CAAR,GAAYD,MAAtC,IAAgDD,MAAM,CAAC+E,UAAP,CAAkB7E,KAAK,GAAG,CAA1B,MAAiC;AAAM;AAA3F,YAAsG;AAClGsE,YAAAA,OAAO,GAD2F,CACtF;;AACZA,YAAAA,OAAO,GAF2F,CAEtF;;AACZA,YAAAA,OAAO,GAH2F,CAGtF;;AACZpE,YAAAA,KAAK,GAAGL,KAAK,CAACkC,IAAd;AACA,mBAAO7B,KAAP;AACH;;AAED,cAAIE,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAJ,EAAqC;AACjClD,YAAAA,KAAK,GAAGmF,UAAU,EAAlB;AACA,mBAAOnF,KAAP;AACH;AACJ;;AACDA,QAAAA,KAAK,GAAGL,KAAK,CAACgC,OAAd;AACA,eAAO3B,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACmC,EAAd;AACA,eAAO9B,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACoC,EAAd;AACA,eAAO/B,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAAC6C,IAAd;AACA,eAAOxC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAAC8C,IAAd;AACA,eAAOzC,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAAC+C,QAAd;AACA,eAAO1C,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACgD,IAAd;AACA,eAAO3C,KAAP;;AAEJ,WAAK,IAAL;AAAY;AACRoE,QAAAA,OAAO;AACPpE,QAAAA,KAAK,GAAGL,KAAK,CAACiD,KAAd;AACA,eAAO5C,KAAP;;AAEJ,WAAK,IAAL;AAAW;AACPA,QAAAA,KAAK,GAAGmF,UAAU,EAAlB;AACA,eAAOnF,KAAP;;AAEJ;AACI,YAAIE,OAAO,CAACoD,IAAR,CAAaiC,cAAb,CAA4BrC,EAA5B,CAAJ,EAAqC;AACjClD,UAAAA,KAAK,GAAGmF,UAAU,EAAlB;AACA,iBAAOnF,KAAP;AACH,SAJL,CAMI;AACA;AACA;AACA;AACA;;;AACAG,QAAAA,OAAO,CAACyF,MAAR,CAAe3C,UAAU,CAACC,EAAD,CAAzB;AACAlD,QAAAA,KAAK,GAAGyF,YAAY,EAApB;AACA,eAAOzF,KAAP;AA5HJ;AA8HH;;AAED,WAAS6F,OAAT,CAAiBC,MAAjB,EAAyBC,IAAzB,EAA+B;AAC3B5F,IAAAA,OAAO,CAACyF,MAAR,CAAe5F,KAAK,KAAK8F,MAAzB,EAAiCC,IAAI,IAAI,4BAAzC;AACAJ,IAAAA,IAAI;AACP;;AAED,WAASK,MAAT,CAAgBF,MAAhB,EAAwBG,OAAxB,EAAiC;AAC7B,QAAIjG,KAAK,KAAK8F,MAAd,EAAsB;AAClB3F,MAAAA,OAAO,CAAC+E,UAAR,CAAmBe,OAAO,IAAI,kBAA9B;AACH;;AACDN,IAAAA,IAAI;AACP,GAlfQ,CAofT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASO,cAAT,GAA0B;AACtB,QAAIC,QAAJ;AAAA,QAAcC,UAAU,GAAGtG,KAAK,GAAG,CAAnC;AACA+F,IAAAA,OAAO,CAAClG,KAAK,CAACqC,MAAP,EAAe,+BAAf,CAAP;AACAmE,IAAAA,QAAQ,GAAG,EAAX;;AACA,QAAInG,KAAK,KAAKL,KAAK,CAACsC,MAApB,EAA4B;AACxB,aAAO,IAAP,EAAa;AACTkE,QAAAA,QAAQ,CAACE,IAAT,CAAcC,mBAAmB,EAAjC;;AACA,YAAItG,KAAK,KAAKL,KAAK,CAACsC,MAApB,EAA4B;AACxB;AACH;;AACD+D,QAAAA,MAAM,CAACrG,KAAK,CAAC8C,IAAP,CAAN;AACH;AACJ;;AACDoD,IAAAA,OAAO,CAAClG,KAAK,CAACsC,MAAP,EAAe,6BAAf,CAAP;AACA,WAAOgC,aAAa,CAAC;AACjBsC,MAAAA,IAAI,EAAE7G,MAAM,CAACkB,SADI;AAEjBuF,MAAAA,QAAQ,EAAEA;AAFO,KAAD,EAGjB,CAACC,UAAD,EAAarG,QAAb,CAHiB,CAApB;AAIH,GA/gBQ,CAihBT;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASyG,cAAT,GAA0B;AACtB,QAAIL,QAAJ;AAAA,QAAcC,UAAU,GAAGtG,KAAK,GAAG,CAAnC;AAAA,QAAsC2G,cAAtC;AACAZ,IAAAA,OAAO,CAAClG,KAAK,CAACyC,MAAP,EAAe,+BAAf,CAAP;AACA+D,IAAAA,QAAQ,GAAG,EAAX;;AACA,WAAOnG,KAAK,KAAKL,KAAK,CAAC0C,MAAvB,EAA+B;AAC3B,UAAIrC,KAAK,KAAKL,KAAK,CAACkC,IAApB,EAA0B;AACtB4E,QAAAA,cAAc,GAAG3G,KAAK,GAAG,CAAzB;AACA+F,QAAAA,OAAO,CAAClG,KAAK,CAACkC,IAAP,CAAP;AACAsE,QAAAA,QAAQ,CAACE,IAAT,CAAcpC,aAAa,CAAC;AACxBsC,UAAAA,IAAI,EAAE7G,MAAM,CAACwB,QADW;AAExBwF,UAAAA,UAAU,EAAEJ,mBAAmB;AAFP,SAAD,EAGxB,CAACG,cAAD,EAAiB1G,QAAjB,CAHwB,CAA3B;AAIA;AACH,OARD,MAQO;AACHoG,QAAAA,QAAQ,CAACE,IAAT,CAAcC,mBAAmB,EAAjC;AACH;;AACD,UAAItG,KAAK,KAAKL,KAAK,CAAC0C,MAApB,EAA4B;AACxB2D,QAAAA,MAAM,CAACrG,KAAK,CAAC2C,KAAP,CAAN;AACH;AACJ;;AACD0D,IAAAA,MAAM,CAACrG,KAAK,CAAC0C,MAAP,CAAN;AACA,WAAO4B,aAAa,CAAC;AACjBsC,MAAAA,IAAI,EAAE7G,MAAM,CAACmB,SADI;AAEjBsF,MAAAA,QAAQ,EAAEA;AAFO,KAAD,EAGjB,CAACC,UAAD,EAAarG,QAAb,CAHiB,CAApB;AAIH;;AAED,WAAS4G,cAAT,GAA0B;AACtB,QAAIC,CAAC,GAAG3G,KAAR;;AACA,QAAID,KAAK,KAAKL,KAAK,CAACkD,IAAhB,IAAwB7C,KAAK,KAAKL,KAAK,CAACmD,MAA5C,EAAoD;AAChD6C,MAAAA,IAAI;AACJ,aAAOiB,CAAP;AACH;;AAED,QAAI5G,KAAK,KAAKL,KAAK,CAACoD,MAApB,EAA4B;AACxB8C,MAAAA,OAAO,CAAClG,KAAK,CAACoD,MAAP,CAAP;AACA,aAAOK,MAAM,CAACwD,CAAD,CAAb;AACH;;AAEDzG,IAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH,GAhkBQ,CAkkBT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAS2B,cAAT,GAA0B;AACtB,QAAIC,GAAJ;AAAA,QAASC,UAAU,GAAGhH,QAAtB;AAEA+G,IAAAA,GAAG,GAAGH,cAAc,EAApB;;AACA,QAAI3G,KAAK,KAAKL,KAAK,CAAC4C,KAApB,EAA2B;AACvBsD,MAAAA,OAAO,CAAClG,KAAK,CAAC4C,KAAP,CAAP;AACA,aAAO0B,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAACqB,SADI;AAEjB+F,QAAAA,GAAG,EAAEA,GAFY;AAGjB7G,QAAAA,KAAK,EAAEqG,mBAAmB;AAHT,OAAD,EAIjB,CAACS,UAAD,EAAahH,QAAb,CAJiB,CAApB;AAKH;;AACD,WAAOkE,aAAa,CAAC;AACjBsC,MAAAA,IAAI,EAAE7G,MAAM,CAACqB,SADI;AAEjB+F,MAAAA,GAAG,EAAEA,GAFY;AAGjB7G,MAAAA,KAAK,EAAE;AAHU,KAAD,EAIjB,CAAC8G,UAAD,EAAahH,QAAb,CAJiB,CAApB;AAKH,GA5lBQ,CA8lBT;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASiH,eAAT,GAA2B;AACvB,QAAIC,MAAJ;AAAA,QAAYF,UAAU,GAAGjH,KAAK,GAAG,CAAjC;AAAA,QAAoCoH,QAApC;AAEArB,IAAAA,OAAO,CAAClG,KAAK,CAACuC,MAAP,EAAe,gCAAf,CAAP;AACA+E,IAAAA,MAAM,GAAG,EAAT;;AACA,QAAIjH,KAAK,KAAKL,KAAK,CAAC2C,KAApB,EAA2B;AACvBuD,MAAAA,OAAO,CAAClG,KAAK,CAAC2C,KAAP,CAAP;AACH,KAFD,MAEO;AACH,aAAOtC,KAAK,KAAKL,KAAK,CAACwC,MAAvB,EAA+B;AAC3B8E,QAAAA,MAAM,CAACZ,IAAP,CAAYQ,cAAc,EAA1B;;AACA,YAAI7G,KAAK,KAAKL,KAAK,CAACwC,MAApB,EAA4B;AACxB6D,UAAAA,MAAM,CAACrG,KAAK,CAAC2C,KAAP,CAAN;AACH;AACJ;AACJ;;AACD4E,IAAAA,QAAQ,GAAGpH,KAAX;AACAkG,IAAAA,MAAM,CAACrG,KAAK,CAACwC,MAAP,CAAN;AACA,WAAO8B,aAAa,CAAC;AACjBsC,MAAAA,IAAI,EAAE7G,MAAM,CAACoB,UADI;AAEjBmG,MAAAA,MAAM,EAAEA;AAFS,KAAD,EAGjB,CAACF,UAAD,EAAaG,QAAb,CAHiB,CAApB;AAIH,GAznBQ,CA2nBT;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASC,mBAAT,GAA+B;AAC3B,QAAIC,IAAI,GAAGnH,KAAX;AAAA,QAAkB8G,UAAU,GAAGjH,KAAK,GAAGsH,IAAI,CAACvH,MAA5C;AACAmG,IAAAA,MAAM,CAACrG,KAAK,CAACkD,IAAP,CAAN;;AAEA,QAAI7C,KAAK,KAAKL,KAAK,CAAC4C,KAAhB,KACI6E,IAAI,KAAK,QAAT,IACAA,IAAI,KAAK,UADT,IAEAA,IAAI,KAAK,OAHb,CAAJ,EAG2B;AACvBvB,MAAAA,OAAO,CAAClG,KAAK,CAAC4C,KAAP,CAAP;AACA6E,MAAAA,IAAI,IAAI,MAAMnH,KAAd;AACA+F,MAAAA,MAAM,CAACrG,KAAK,CAACkD,IAAP,CAAN;AACH;;AAED,WAAOoB,aAAa,CAAC;AACjBsC,MAAAA,IAAI,EAAE7G,MAAM,CAAC4B,cADI;AAEjB8F,MAAAA,IAAI,EAAEA;AAFW,KAAD,EAGjB,CAACL,UAAD,EAAahH,QAAb,CAHiB,CAApB;AAIH,GAnpBQ,CAqpBT;AACA;AACA;;;AACA,WAASsH,uBAAT,GAAmC;AAC/B,QAAIlB,QAAQ,GAAG,EAAf;AAEAA,IAAAA,QAAQ,CAACE,IAAT,CAAciB,QAAQ,EAAtB;;AACA,WAAOtH,KAAK,KAAKL,KAAK,CAAC2C,KAAvB,EAA8B;AAC1BuD,MAAAA,OAAO,CAAClG,KAAK,CAAC2C,KAAP,CAAP;AACA6D,MAAAA,QAAQ,CAACE,IAAT,CAAciB,QAAQ,EAAtB;AACH;;AACD,WAAOnB,QAAP;AACH,GAjqBQ,CAmqBT;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASoB,aAAT,GAAyB;AACrB,QAAIC,IAAJ;AAAA,QAAUC,YAAV;AAAA,QAAwBrB,UAAU,GAAGtG,KAAK,GAAGG,KAAK,CAACJ,MAAnD;AAEA2H,IAAAA,IAAI,GAAGL,mBAAmB,EAA1B;;AACA,QAAInH,KAAK,KAAKL,KAAK,CAACiC,MAAhB,IAA0B5B,KAAK,KAAKL,KAAK,CAACmC,EAA9C,EAAkD;AAC9C6D,MAAAA,IAAI;AACJ8B,MAAAA,YAAY,GAAGJ,uBAAuB,EAAtC;AACArB,MAAAA,MAAM,CAACrG,KAAK,CAACoC,EAAP,CAAN;AACA,aAAOkC,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAAC6B,eADI;AAEjBmF,QAAAA,UAAU,EAAEc,IAFK;AAGjBC,QAAAA,YAAY,EAAEA;AAHG,OAAD,EAIjB,CAACrB,UAAD,EAAarG,QAAb,CAJiB,CAApB;AAKH;;AACD,WAAOyH,IAAP;AACH,GAzrBQ,CA2rBT;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASE,eAAT,GAA2B;AACvB7B,IAAAA,OAAO,CAAClG,KAAK,CAAC4C,KAAP,EAAc,gCAAd,CAAP;;AACA,QAAIvC,KAAK,KAAKL,KAAK,CAACkD,IAAhB,IAAwB5C,KAAK,KAAK,MAAtC,EAA8C;AAC1C4F,MAAAA,OAAO,CAAClG,KAAK,CAACkD,IAAP,CAAP;AACA,aAAO;AACH0D,QAAAA,IAAI,EAAE7G,MAAM,CAACiB;AADV,OAAP;AAGH;;AACD,WAAO2F,mBAAmB,EAA1B;AACH,GA3sBQ,CA6sBT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASqB,mBAAT,GAA+B;AAC3B,QAAIC,MAAM,GAAG,EAAb;AAAA,QAAiBC,gBAAgB,GAAG,KAApC;AAAA,QAA2CL,IAA3C;AAAA,QAAiDM,IAAI,GAAG,KAAxD;AAAA,QAA+D1B,UAA/D;AAAA,QAA2EK,cAAc,GAAG3G,KAAK,GAAG,CAApG;AAAA,QAAuGiI,cAAvG;;AAEA,WAAO/H,KAAK,KAAKL,KAAK,CAACsC,MAAvB,EAA+B;AAC3B,UAAIjC,KAAK,KAAKL,KAAK,CAACkC,IAApB,EAA0B;AACtB;AACAgE,QAAAA,OAAO,CAAClG,KAAK,CAACkC,IAAP,CAAP;AACAiG,QAAAA,IAAI,GAAG,IAAP;AACH;;AAED1B,MAAAA,UAAU,GAAGrG,QAAb;AAEAyH,MAAAA,IAAI,GAAGlB,mBAAmB,EAA1B;;AACA,UAAIkB,IAAI,CAACjB,IAAL,KAAc7G,MAAM,CAAC4B,cAArB,IAAuCtB,KAAK,KAAKL,KAAK,CAAC4C,KAA3D,EAAkE;AAC9DwF,QAAAA,cAAc,GAAGhI,QAAQ,GAAGyH,IAAI,CAACJ,IAAL,CAAUvH,MAAtC,CAD8D,CAE9D;;AACAgG,QAAAA,OAAO,CAAClG,KAAK,CAAC4C,KAAP,CAAP;AACAiF,QAAAA,IAAI,GAAGvD,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAACuB,aADI;AAEjBmG,UAAAA,IAAI,EAAEI,IAAI,CAACJ,IAFM;AAGjBV,UAAAA,UAAU,EAAEJ,mBAAmB;AAHd,SAAD,EAIjB,CAACyB,cAAD,EAAiBhI,QAAjB,CAJiB,CAApB;AAKH;;AACD,UAAIC,KAAK,KAAKL,KAAK,CAACiD,KAApB,EAA2B;AACvBiD,QAAAA,OAAO,CAAClG,KAAK,CAACiD,KAAP,CAAP;AACA4E,QAAAA,IAAI,GAAGvD,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAAC0B,YADI;AAEjBsF,UAAAA,UAAU,EAAEc;AAFK,SAAD,EAGjB,CAACpB,UAAD,EAAarG,QAAb,CAHiB,CAApB;AAIA8H,QAAAA,gBAAgB,GAAG,IAAnB;AACH,OAPD,MAOO;AACH,YAAIA,gBAAJ,EAAsB;AAClB1H,UAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;AACJ;;AACD,UAAI4C,IAAJ,EAAU;AACNN,QAAAA,IAAI,GAAGvD,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAACwB,QADI;AAEjBwF,UAAAA,UAAU,EAAEc;AAFK,SAAD,EAGjB,CAACf,cAAD,EAAiB1G,QAAjB,CAHiB,CAApB;AAIH;;AACD6H,MAAAA,MAAM,CAACvB,IAAP,CAAYmB,IAAZ;;AACA,UAAIxH,KAAK,KAAKL,KAAK,CAACsC,MAApB,EAA4B;AACxB+D,QAAAA,MAAM,CAACrG,KAAK,CAAC2C,KAAP,CAAN;AACH;AACJ;;AACD,WAAOsF,MAAP;AACH,GAnxBQ,CAqxBT;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASI,iBAAT,GAA6B;AACzB,QAAIC,KAAJ;AAAA,QAAWC,WAAX;AAAA,QAAwBN,MAAxB;AAAA,QAAgCO,MAAhC;AAAA,QAAwCC,MAAxC;AAAA,QAAgDhC,UAAU,GAAGtG,KAAK,GAAGG,KAAK,CAACJ,MAA3E;AACAM,IAAAA,OAAO,CAACyF,MAAR,CAAe5F,KAAK,KAAKL,KAAK,CAACkD,IAAhB,IAAwB5C,KAAK,KAAK,UAAjD,EAA6D,6CAA7D;AACA4F,IAAAA,OAAO,CAAClG,KAAK,CAACkD,IAAP,CAAP,CAHyB,CAKzB;AACA;;AACAmD,IAAAA,MAAM,CAACrG,KAAK,CAACqC,MAAP,CAAN;AAEAiG,IAAAA,KAAK,GAAG,KAAR;AACAL,IAAAA,MAAM,GAAG,EAAT;AACAM,IAAAA,WAAW,GAAG,IAAd;;AACA,QAAIlI,KAAK,KAAKL,KAAK,CAACsC,MAApB,EAA4B;AACxB;AACA,UAAIjC,KAAK,KAAKL,KAAK,CAACkD,IAAhB,KACK5C,KAAK,KAAK,MAAV,IAAoBA,KAAK,KAAK,KADnC,CAAJ,EAC+C;AAC3C;AACA;AACAgI,QAAAA,KAAK,GAAGhI,KAAK,KAAK,KAAlB;AACA4F,QAAAA,OAAO,CAAClG,KAAK,CAACkD,IAAP,CAAP;AACAmD,QAAAA,MAAM,CAACrG,KAAK,CAAC4C,KAAP,CAAN;AACA2F,QAAAA,WAAW,GAAGX,aAAa,EAA3B;;AACA,YAAIvH,KAAK,KAAKL,KAAK,CAAC2C,KAApB,EAA2B;AACvBuD,UAAAA,OAAO,CAAClG,KAAK,CAAC2C,KAAP,CAAP;AACAsF,UAAAA,MAAM,GAAGD,mBAAmB,EAA5B;AACH;AACJ,OAZD,MAYO;AACHC,QAAAA,MAAM,GAAGD,mBAAmB,EAA5B;AACH;AACJ;;AAED3B,IAAAA,MAAM,CAACrG,KAAK,CAACsC,MAAP,CAAN;AAEAkG,IAAAA,MAAM,GAAG,IAAT;;AACA,QAAInI,KAAK,KAAKL,KAAK,CAAC4C,KAApB,EAA2B;AACvB4F,MAAAA,MAAM,GAAGT,eAAe,EAAxB;AACH;;AAEDU,IAAAA,MAAM,GAAGnE,aAAa,CAAC;AACnBsC,MAAAA,IAAI,EAAE7G,MAAM,CAACsB,YADM;AAEnB4G,MAAAA,MAAM,EAAEA,MAFW;AAGnBO,MAAAA,MAAM,EAAEA;AAHW,KAAD,EAInB,CAAC/B,UAAD,EAAarG,QAAb,CAJmB,CAAtB;;AAKA,QAAImI,WAAJ,EAAiB;AACb;AACAE,MAAAA,MAAM,CAAC,MAAD,CAAN,GAAiBF,WAAjB;;AACA,UAAID,KAAJ,EAAW;AACPG,QAAAA,MAAM,CAAC,KAAD,CAAN,GAAgB,IAAhB;AACH;AACJ;;AACD,WAAOA,MAAP;AACH,GA/0BQ,CAi1BT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASC,wBAAT,GAAoC;AAChC,QAAIC,OAAJ,EAAalC,UAAb;;AACA,YAAQpG,KAAR;AACA,WAAKL,KAAK,CAAC6C,IAAX;AACIqD,QAAAA,OAAO,CAAClG,KAAK,CAAC6C,IAAP,CAAP;AACA,eAAOyB,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAACc;AADI,SAAD,EAEjB,CAACT,QAAQ,GAAG,CAAZ,EAAeA,QAAf,CAFiB,CAApB;;AAIJ,WAAKJ,KAAK,CAACqC,MAAX;AACI,eAAOkE,cAAc,EAArB;;AAEJ,WAAKvG,KAAK,CAACyC,MAAX;AACI,eAAOoE,cAAc,EAArB;;AAEJ,WAAK7G,KAAK,CAACuC,MAAX;AACI,eAAO8E,eAAe,EAAtB;;AAEJ,WAAKrH,KAAK,CAACkD,IAAX;AACIuD,QAAAA,UAAU,GAAGtG,KAAK,GAAGG,KAAK,CAACJ,MAA3B;;AAEA,YAAII,KAAK,KAAK,MAAd,EAAsB;AAClB4F,UAAAA,OAAO,CAAClG,KAAK,CAACkD,IAAP,CAAP;AACA,iBAAOoB,aAAa,CAAC;AACjBsC,YAAAA,IAAI,EAAE7G,MAAM,CAACe;AADI,WAAD,EAEjB,CAAC2F,UAAD,EAAarG,QAAb,CAFiB,CAApB;AAGH;;AAED,YAAIE,KAAK,KAAK,WAAd,EAA2B;AACvB4F,UAAAA,OAAO,CAAClG,KAAK,CAACkD,IAAP,CAAP;AACA,iBAAOoB,aAAa,CAAC;AACjBsC,YAAAA,IAAI,EAAE7G,MAAM,CAACgB;AADI,WAAD,EAEjB,CAAC0F,UAAD,EAAarG,QAAb,CAFiB,CAApB;AAGH;;AAED,YAAIE,KAAK,KAAK,MAAV,IAAoBA,KAAK,KAAK,OAAlC,EAA2C;AACvC4F,UAAAA,OAAO,CAAClG,KAAK,CAACkD,IAAP,CAAP;AACA,iBAAOoB,aAAa,CAAC;AACjBsC,YAAAA,IAAI,EAAE7G,MAAM,CAACgC,kBADI;AAEjBzB,YAAAA,KAAK,EAAEA,KAAK,KAAK;AAFA,WAAD,EAGjB,CAACmG,UAAD,EAAarG,QAAb,CAHiB,CAApB;AAIH;;AAEDuI,QAAAA,OAAO,GAAG7E,OAAO,CAACO,IAAR,EAAV;;AACA,YAAI/D,KAAK,KAAK,UAAd,EAA0B;AACtB,cAAI;AACA,mBAAO+H,iBAAiB,EAAxB;AACH,WAFD,CAEE,OAAOO,CAAP,EAAU;AACRD,YAAAA,OAAO,CAACvE,OAAR;AACH;AACJ;;AAED,eAAOwD,aAAa,EAApB;;AAEJ,WAAK5H,KAAK,CAACmD,MAAX;AACI6C,QAAAA,IAAI;AACJ,eAAO1B,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAAC8B,iBADI;AAEjBvB,UAAAA,KAAK,EAAEA;AAFU,SAAD,EAGjB,CAACF,QAAQ,GAAGE,KAAK,CAACJ,MAAjB,GAA0B,CAA3B,EAA8BE,QAA9B,CAHiB,CAApB;;AAKJ,WAAKJ,KAAK,CAACoD,MAAX;AACI4C,QAAAA,IAAI;AACJ,eAAO1B,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAAC+B,kBADI;AAEjBxB,UAAAA,KAAK,EAAEA;AAFU,SAAD,EAGjB,CAACF,QAAQ,GAAGqD,MAAM,CAACnD,KAAD,CAAN,CAAcJ,MAA1B,EAAkCE,QAAlC,CAHiB,CAApB;;AAKJ;AACII,QAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AAnEJ;AAqEH,GAj6BQ,CAm6BT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASoB,mBAAT,GAA+B;AAC3B,QAAIkB,IAAJ,EAAUT,UAAV;;AAEA,QAAI/G,KAAK,KAAKL,KAAK,CAAC+C,QAApB,EAA8B;AAC1BqE,MAAAA,UAAU,GAAGjH,KAAK,GAAG,CAArB;AACA+F,MAAAA,OAAO,CAAClG,KAAK,CAAC+C,QAAP,CAAP;;AACA,UAAI1C,KAAK,KAAKL,KAAK,CAAC2C,KAAhB,IAAyBtC,KAAK,KAAKL,KAAK,CAACiD,KAAzC,IAAkD5C,KAAK,KAAKL,KAAK,CAACwC,MAAlE,IACInC,KAAK,KAAKL,KAAK,CAACsC,MADpB,IAC8BjC,KAAK,KAAKL,KAAK,CAAC8C,IAD9C,IACsDzC,KAAK,KAAKL,KAAK,CAACqD,GADtE,IAEIhD,KAAK,KAAKL,KAAK,CAAC0C,MAFpB,IAE8BrC,KAAK,KAAKL,KAAK,CAACoC,EAFlD,EAEsD;AAClD,eAAOkC,aAAa,CAAC;AACjBsC,UAAAA,IAAI,EAAE7G,MAAM,CAACa;AADI,SAAD,EAEjB,CAACwG,UAAD,EAAahH,QAAb,CAFiB,CAApB;AAGH;;AACD,aAAOkE,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAAC2B,YADI;AAEjBqF,QAAAA,UAAU,EAAE2B,wBAAwB,EAFnB;AAGjB9D,QAAAA,MAAM,EAAE;AAHS,OAAD,EAIjB,CAACwC,UAAD,EAAahH,QAAb,CAJiB,CAApB;AAKH,KAfD,MAeO,IAAIC,KAAK,KAAKL,KAAK,CAACgD,IAApB,EAA0B;AAC7BoE,MAAAA,UAAU,GAAGjH,KAAK,GAAG,CAArB;AACA+F,MAAAA,OAAO,CAAClG,KAAK,CAACgD,IAAP,CAAP;AACA,aAAOsB,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAACyB,eADI;AAEjBuF,QAAAA,UAAU,EAAE2B,wBAAwB,EAFnB;AAGjB9D,QAAAA,MAAM,EAAE;AAHS,OAAD,EAIjB,CAACwC,UAAD,EAAahH,QAAb,CAJiB,CAApB;AAKH,KARM,MAQA;AACHgH,MAAAA,UAAU,GAAGhH,QAAb;AACH;;AAEDyH,IAAAA,IAAI,GAAGa,wBAAwB,EAA/B;;AACA,QAAIrI,KAAK,KAAKL,KAAK,CAACgD,IAApB,EAA0B;AACtBkD,MAAAA,OAAO,CAAClG,KAAK,CAACgD,IAAP,CAAP;AACA,aAAOsB,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAACyB,eADI;AAEjBuF,QAAAA,UAAU,EAAEc,IAFK;AAGjBjD,QAAAA,MAAM,EAAE;AAHS,OAAD,EAIjB,CAACwC,UAAD,EAAahH,QAAb,CAJiB,CAApB;AAKH;;AAED,QAAIC,KAAK,KAAKL,KAAK,CAAC+C,QAApB,EAA8B;AAC1BmD,MAAAA,OAAO,CAAClG,KAAK,CAAC+C,QAAP,CAAP;AACA,aAAOuB,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAAC2B,YADI;AAEjBqF,QAAAA,UAAU,EAAEc,IAFK;AAGjBjD,QAAAA,MAAM,EAAE;AAHS,OAAD,EAIjB,CAACwC,UAAD,EAAahH,QAAb,CAJiB,CAApB;AAKH;;AAED,QAAIC,KAAK,KAAKL,KAAK,CAACyC,MAApB,EAA4B;AACxByD,MAAAA,OAAO,CAAClG,KAAK,CAACyC,MAAP,CAAP;AACA4D,MAAAA,MAAM,CAACrG,KAAK,CAAC0C,MAAP,EAAe,+CAA+CpC,KAA/C,GAAuD,KAAtE,CAAN;AACA,aAAOgE,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAAC6B,eADI;AAEjBmF,QAAAA,UAAU,EAAEzC,aAAa,CAAC;AACtBsC,UAAAA,IAAI,EAAE7G,MAAM,CAAC4B,cADS;AAEtB8F,UAAAA,IAAI,EAAE;AAFgB,SAAD,EAGtB,CAACL,UAAD,EAAahH,QAAb,CAHsB,CAFR;AAMjB0H,QAAAA,YAAY,EAAE,CAACD,IAAD;AANG,OAAD,EAOjB,CAACT,UAAD,EAAahH,QAAb,CAPiB,CAApB;AAQH;;AAED,WAAOyH,IAAP;AACH,GA1+BQ,CA4+BT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAASF,QAAT,GAAoB;AAChB,QAAIE,IAAJ,EAAUrB,QAAV;AAEAqB,IAAAA,IAAI,GAAGlB,mBAAmB,EAA1B;;AACA,QAAItG,KAAK,KAAKL,KAAK,CAAC8C,IAApB,EAA0B;AACtB,aAAO+E,IAAP;AACH;;AAEDrB,IAAAA,QAAQ,GAAG,CAACqB,IAAD,CAAX;AACA3B,IAAAA,OAAO,CAAClG,KAAK,CAAC8C,IAAP,CAAP;;AACA,WAAO,IAAP,EAAa;AACT0D,MAAAA,QAAQ,CAACE,IAAT,CAAcC,mBAAmB,EAAjC;;AACA,UAAItG,KAAK,KAAKL,KAAK,CAAC8C,IAApB,EAA0B;AACtB;AACH;;AACDoD,MAAAA,OAAO,CAAClG,KAAK,CAAC8C,IAAP,CAAP;AACH;;AAED,WAAOwB,aAAa,CAAC;AACjBsC,MAAAA,IAAI,EAAE7G,MAAM,CAACkB,SADI;AAEjBuF,MAAAA,QAAQ,EAAEA;AAFO,KAAD,EAGjB,CAAC,CAAD,EAAIrG,KAAJ,CAHiB,CAApB;AAIH;;AAED,WAAS0I,iBAAT,GAA6B;AACzB,QAAIhB,IAAJ;;AAEA,QAAIxH,KAAK,KAAKL,KAAK,CAACkC,IAApB,EAA0B;AACtBgE,MAAAA,OAAO,CAAClG,KAAK,CAACkC,IAAP,CAAP;AACA,aAAOoC,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAACwB,QADI;AAEjBwF,QAAAA,UAAU,EAAEY,QAAQ;AAFH,OAAD,EAGjB,CAAC,CAAD,EAAIxH,KAAJ,CAHiB,CAApB;AAIH;;AAED0H,IAAAA,IAAI,GAAGF,QAAQ,EAAf;;AACA,QAAItH,KAAK,KAAKL,KAAK,CAACiD,KAApB,EAA2B;AACvBiD,MAAAA,OAAO,CAAClG,KAAK,CAACiD,KAAP,CAAP;AACA,aAAOqB,aAAa,CAAC;AACjBsC,QAAAA,IAAI,EAAE7G,MAAM,CAAC0B,YADI;AAEjBsF,QAAAA,UAAU,EAAEc;AAFK,OAAD,EAGjB,CAAC,CAAD,EAAI1H,KAAJ,CAHiB,CAApB;AAIH;;AAED,WAAO0H,IAAP;AACH;;AAED,WAASiB,SAAT,CAAmBC,GAAnB,EAAwBC,GAAxB,EAA6B;AACzB,QAAInB,IAAJ;AAEA5H,IAAAA,MAAM,GAAG8I,GAAT;AACA7I,IAAAA,MAAM,GAAGD,MAAM,CAACC,MAAhB;AACAC,IAAAA,KAAK,GAAG,CAAR;AACAC,IAAAA,QAAQ,GAAG,CAAX;AACAM,IAAAA,QAAQ,GAAGsI,GAAG,IAAIA,GAAG,CAACxE,KAAtB;AACA/D,IAAAA,WAAW,GAAGuI,GAAG,IAAIA,GAAG,CAACvC,UAAX,IAAyB,CAAvC;AAEAT,IAAAA,IAAI;AACJ6B,IAAAA,IAAI,GAAGF,QAAQ,EAAf;;AAEA,QAAIqB,GAAG,IAAIA,GAAG,CAACC,SAAf,EAA0B;AACtB,aAAO;AACHlC,QAAAA,UAAU,EAAEc,IADT;AAEH1H,QAAAA,KAAK,EAAEC;AAFJ,OAAP;AAIH;;AAED,QAAIC,KAAK,KAAKL,KAAK,CAACqD,GAApB,EAAyB;AACrB7C,MAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;;AAED,WAAOsC,IAAP;AACH;;AAED,WAASqB,cAAT,CAAwBH,GAAxB,EAA6BC,GAA7B,EAAkC;AAC9B,QAAInB,IAAJ;AAEA5H,IAAAA,MAAM,GAAG8I,GAAT;AACA7I,IAAAA,MAAM,GAAGD,MAAM,CAACC,MAAhB;AACAC,IAAAA,KAAK,GAAG,CAAR;AACAC,IAAAA,QAAQ,GAAG,CAAX;AACAM,IAAAA,QAAQ,GAAGsI,GAAG,IAAIA,GAAG,CAACxE,KAAtB;AACA/D,IAAAA,WAAW,GAAGuI,GAAG,IAAIA,GAAG,CAACvC,UAAX,IAAyB,CAAvC;AAEAT,IAAAA,IAAI;AACJ6B,IAAAA,IAAI,GAAGgB,iBAAiB,EAAxB;;AAEA,QAAIG,GAAG,IAAIA,GAAG,CAACC,SAAf,EAA0B;AACtB,aAAO;AACHlC,QAAAA,UAAU,EAAEc,IADT;AAEH1H,QAAAA,KAAK,EAAEC;AAFJ,OAAP;AAIH;;AAED,QAAIC,KAAK,KAAKL,KAAK,CAACqD,GAApB,EAAyB;AACrB7C,MAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAnB;AACH;;AAED,WAAOsC,IAAP;AACH;;AAED,WAASsB,aAAT,CAAuB5E,IAAvB,EAA6B6E,OAA7B,EAAsCC,QAAtC,EAAgD;AAC5C,QAAIb,MAAJ,EAAY3D,CAAZ,EAAeyE,EAAf;;AAEA,YAAQ/E,IAAI,CAACqC,IAAb;AACA,WAAK7G,MAAM,CAACa,eAAZ;AACI4H,QAAAA,MAAM,GAAG,GAAT;AACA;;AAEJ,WAAKzI,MAAM,CAACc,UAAZ;AACI2H,QAAAA,MAAM,GAAG,GAAT;AACA;;AAEJ,WAAKzI,MAAM,CAACe,WAAZ;AACI0H,QAAAA,MAAM,GAAG,MAAT;AACA;;AAEJ,WAAKzI,MAAM,CAACgB,gBAAZ;AACIyH,QAAAA,MAAM,GAAG,WAAT;AACA;;AAEJ,WAAKzI,MAAM,CAACiB,WAAZ;AACIwH,QAAAA,MAAM,GAAG,MAAT;AACA;;AAEJ,WAAKzI,MAAM,CAACkB,SAAZ;AACI,YAAI,CAACoI,QAAL,EAAe;AACXb,UAAAA,MAAM,GAAG,GAAT;AACH,SAFD,MAEO;AACHA,UAAAA,MAAM,GAAG,EAAT;AACH;;AAED,aAAK3D,CAAC,GAAG,CAAJ,EAAOyE,EAAE,GAAG/E,IAAI,CAACiC,QAAL,CAActG,MAA/B,EAAuC2E,CAAC,GAAGyE,EAA3C,EAA+C,EAAEzE,CAAjD,EAAoD;AAChD2D,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAACiC,QAAL,CAAc3B,CAAd,CAAD,EAAmBuE,OAAnB,CAAvB;;AACA,cAAKvE,CAAC,GAAG,CAAL,KAAYyE,EAAhB,EAAoB;AAChBd,YAAAA,MAAM,IAAIY,OAAO,GAAG,GAAH,GAAS,KAA1B;AACH;AACJ;;AAED,YAAI,CAACC,QAAL,EAAe;AACXb,UAAAA,MAAM,IAAI,GAAV;AACH;;AACD;;AAEJ,WAAKzI,MAAM,CAACmB,SAAZ;AACIsH,QAAAA,MAAM,GAAG,GAAT;;AACA,aAAK3D,CAAC,GAAG,CAAJ,EAAOyE,EAAE,GAAG/E,IAAI,CAACiC,QAAL,CAActG,MAA/B,EAAuC2E,CAAC,GAAGyE,EAA3C,EAA+C,EAAEzE,CAAjD,EAAoD;AAChD2D,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAACiC,QAAL,CAAc3B,CAAd,CAAD,EAAmBuE,OAAnB,CAAvB;;AACA,cAAKvE,CAAC,GAAG,CAAL,KAAYyE,EAAhB,EAAoB;AAChBd,YAAAA,MAAM,IAAIY,OAAO,GAAG,GAAH,GAAS,IAA1B;AACH;AACJ;;AACDZ,QAAAA,MAAM,IAAI,GAAV;AACA;;AAEJ,WAAKzI,MAAM,CAACoB,UAAZ;AACIqH,QAAAA,MAAM,GAAG,GAAT;;AACA,aAAK3D,CAAC,GAAG,CAAJ,EAAOyE,EAAE,GAAG/E,IAAI,CAAC+C,MAAL,CAAYpH,MAA7B,EAAqC2E,CAAC,GAAGyE,EAAzC,EAA6C,EAAEzE,CAA/C,EAAkD;AAC9C2D,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAAC+C,MAAL,CAAYzC,CAAZ,CAAD,EAAiBuE,OAAjB,CAAvB;;AACA,cAAKvE,CAAC,GAAG,CAAL,KAAYyE,EAAhB,EAAoB;AAChBd,YAAAA,MAAM,IAAIY,OAAO,GAAG,GAAH,GAAS,IAA1B;AACH;AACJ;;AACDZ,QAAAA,MAAM,IAAI,GAAV;AACA;;AAEJ,WAAKzI,MAAM,CAACqB,SAAZ;AACI,YAAImD,IAAI,CAACjE,KAAT,EAAgB;AACZkI,UAAAA,MAAM,GAAGjE,IAAI,CAAC4C,GAAL,IAAYiC,OAAO,GAAG,GAAH,GAAS,IAA5B,IAAoCD,aAAa,CAAC5E,IAAI,CAACjE,KAAN,EAAa8I,OAAb,CAA1D;AACH,SAFD,MAEO;AACHZ,UAAAA,MAAM,GAAGjE,IAAI,CAAC4C,GAAd;AACH;;AACD;;AAEJ,WAAKpH,MAAM,CAACsB,YAAZ;AACImH,QAAAA,MAAM,GAAGY,OAAO,GAAG,WAAH,GAAiB,YAAjC;;AAEA,YAAI7E,IAAI,CAAC,MAAD,CAAR,EAAkB;AACd,cAAIA,IAAI,CAAC,KAAD,CAAR,EAAiB;AACbiE,YAAAA,MAAM,IAAKY,OAAO,GAAG,MAAH,GAAY,OAA9B;AACH,WAFD,MAEO;AACHZ,YAAAA,MAAM,IAAKY,OAAO,GAAG,OAAH,GAAa,QAA/B;AACH;;AAEDZ,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAAC,MAAD,CAAL,EAAe6E,OAAf,CAAvB;;AAEA,cAAI7E,IAAI,CAAC0D,MAAL,CAAY/H,MAAZ,KAAuB,CAA3B,EAA8B;AAC1BsI,YAAAA,MAAM,IAAIY,OAAO,GAAG,GAAH,GAAS,IAA1B;AACH;AACJ;;AAED,aAAKvE,CAAC,GAAG,CAAJ,EAAOyE,EAAE,GAAG/E,IAAI,CAAC0D,MAAL,CAAY/H,MAA7B,EAAqC2E,CAAC,GAAGyE,EAAzC,EAA6C,EAAEzE,CAA/C,EAAkD;AAC9C2D,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAAC0D,MAAL,CAAYpD,CAAZ,CAAD,EAAiBuE,OAAjB,CAAvB;;AACA,cAAKvE,CAAC,GAAG,CAAL,KAAYyE,EAAhB,EAAoB;AAChBd,YAAAA,MAAM,IAAIY,OAAO,GAAG,GAAH,GAAS,IAA1B;AACH;AACJ;;AAEDZ,QAAAA,MAAM,IAAI,GAAV;;AAEA,YAAIjE,IAAI,CAACiE,MAAT,EAAiB;AACbA,UAAAA,MAAM,IAAI,CAACY,OAAO,GAAG,GAAH,GAAS,IAAjB,IAAyBD,aAAa,CAAC5E,IAAI,CAACiE,MAAN,EAAcY,OAAd,CAAhD;AACH;;AACD;;AAEJ,WAAKrJ,MAAM,CAACuB,aAAZ;AACIkH,QAAAA,MAAM,GAAGjE,IAAI,CAACkD,IAAL,IAAa2B,OAAO,GAAG,GAAH,GAAS,IAA7B,IAAqCD,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAA3D;AACA;;AAEJ,WAAKrJ,MAAM,CAACwB,QAAZ;AACIiH,QAAAA,MAAM,GAAG,KAAT;;AACA,YAAIjE,IAAI,CAACwC,UAAT,EAAqB;AACjByB,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAAvB;AACH;;AACD;;AAEJ,WAAKrJ,MAAM,CAACyB,eAAZ;AACI,YAAI+C,IAAI,CAACK,MAAT,EAAiB;AACb4D,UAAAA,MAAM,GAAG,MAAMW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAA5B;AACH,SAFD,MAEO;AACHZ,UAAAA,MAAM,GAAGW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAAb,GAA0C,GAAnD;AACH;;AACD;;AAEJ,WAAKrJ,MAAM,CAAC0B,YAAZ;AACI+G,QAAAA,MAAM,GAAGW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAAb,GAA0C,GAAnD;AACA;;AAEJ,WAAKrJ,MAAM,CAAC2B,YAAZ;AACI,YAAI6C,IAAI,CAACK,MAAT,EAAiB;AACb4D,UAAAA,MAAM,GAAG,MAAMW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAA5B;AACH,SAFD,MAEO;AACHZ,UAAAA,MAAM,GAAGW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAAb,GAA0C,GAAnD;AACH;;AACD;;AAEJ,WAAKrJ,MAAM,CAAC4B,cAAZ;AACI6G,QAAAA,MAAM,GAAGjE,IAAI,CAACkD,IAAd;AACA;;AAEJ,WAAK1H,MAAM,CAAC6B,eAAZ;AACI4G,QAAAA,MAAM,GAAGW,aAAa,CAAC5E,IAAI,CAACwC,UAAN,EAAkBqC,OAAlB,CAAb,GAA0C,IAAnD;;AACA,aAAKvE,CAAC,GAAG,CAAJ,EAAOyE,EAAE,GAAG/E,IAAI,CAACuD,YAAL,CAAkB5H,MAAnC,EAA2C2E,CAAC,GAAGyE,EAA/C,EAAmD,EAAEzE,CAArD,EAAwD;AACpD2D,UAAAA,MAAM,IAAIW,aAAa,CAAC5E,IAAI,CAACuD,YAAL,CAAkBjD,CAAlB,CAAD,EAAuBuE,OAAvB,CAAvB;;AACA,cAAKvE,CAAC,GAAG,CAAL,KAAYyE,EAAhB,EAAoB;AAChBd,YAAAA,MAAM,IAAIY,OAAO,GAAG,GAAH,GAAS,IAA1B;AACH;AACJ;;AACDZ,QAAAA,MAAM,IAAI,GAAV;AACA;;AAEJ,WAAKzI,MAAM,CAAC8B,iBAAZ;AACI2G,QAAAA,MAAM,GAAG,MAAMjE,IAAI,CAACjE,KAAX,GAAmB,GAA5B;AACA;;AAEJ,WAAKP,MAAM,CAAC+B,kBAAZ;AACI0G,QAAAA,MAAM,GAAG/E,MAAM,CAACc,IAAI,CAACjE,KAAN,CAAf;AACA;;AAEJ,WAAKP,MAAM,CAACgC,kBAAZ;AACIyG,QAAAA,MAAM,GAAG/E,MAAM,CAACc,IAAI,CAACjE,KAAN,CAAf;AACA;;AAEJ;AACIE,QAAAA,OAAO,CAAC+E,UAAR,CAAmB,kBAAkBhB,IAAI,CAACqC,IAA1C;AAhKJ;;AAmKA,WAAO4B,MAAP;AACH;;AAED,WAASe,SAAT,CAAmBhF,IAAnB,EAAyBiF,OAAzB,EAAkC;AAC9B,QAAIA,OAAO,IAAI,IAAf,EAAqB;AACjBA,MAAAA,OAAO,GAAG,EAAV;AACH;;AACD,WAAOL,aAAa,CAAC5E,IAAD,EAAOiF,OAAO,CAACJ,OAAf,EAAwBI,OAAO,CAACH,QAAhC,CAApB;AACH;;AAEDI,EAAAA,OAAO,CAACX,SAAR,GAAoBA,SAApB;AACAW,EAAAA,OAAO,CAACP,cAAR,GAAyBA,cAAzB;AACAO,EAAAA,OAAO,CAACF,SAAR,GAAoBA,SAApB;AACAE,EAAAA,OAAO,CAAC1J,MAAR,GAAiBA,MAAjB;AACH,CA9wCA,GAAD;AA+wCA","sourcesContent":["/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n    'use strict';\n\n    var Syntax,\n        Token,\n        source,\n        length,\n        index,\n        previous,\n        token,\n        value,\n        esutils,\n        utility,\n        rangeOffset,\n        addRange;\n\n    esutils = require('esutils');\n    utility = require('./utility');\n\n    Syntax = {\n        NullableLiteral: 'NullableLiteral',\n        AllLiteral: 'AllLiteral',\n        NullLiteral: 'NullLiteral',\n        UndefinedLiteral: 'UndefinedLiteral',\n        VoidLiteral: 'VoidLiteral',\n        UnionType: 'UnionType',\n        ArrayType: 'ArrayType',\n        RecordType: 'RecordType',\n        FieldType: 'FieldType',\n        FunctionType: 'FunctionType',\n        ParameterType: 'ParameterType',\n        RestType: 'RestType',\n        NonNullableType: 'NonNullableType',\n        OptionalType: 'OptionalType',\n        NullableType: 'NullableType',\n        NameExpression: 'NameExpression',\n        TypeApplication: 'TypeApplication',\n        StringLiteralType: 'StringLiteralType',\n        NumericLiteralType: 'NumericLiteralType',\n        BooleanLiteralType: 'BooleanLiteralType'\n    };\n\n    Token = {\n        ILLEGAL: 0,    // ILLEGAL\n        DOT_LT: 1,     // .<\n        REST: 2,       // ...\n        LT: 3,         // <\n        GT: 4,         // >\n        LPAREN: 5,     // (\n        RPAREN: 6,     // )\n        LBRACE: 7,     // {\n        RBRACE: 8,     // }\n        LBRACK: 9,    // [\n        RBRACK: 10,    // ]\n        COMMA: 11,     // ,\n        COLON: 12,     // :\n        STAR: 13,      // *\n        PIPE: 14,      // |\n        QUESTION: 15,  // ?\n        BANG: 16,      // !\n        EQUAL: 17,     // =\n        NAME: 18,      // name token\n        STRING: 19,    // string\n        NUMBER: 20,    // number\n        EOF: 21\n    };\n\n    function isTypeName(ch) {\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n\n    Context.prototype.restore = function () {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n\n    Context.save = function () {\n        return new Context(previous, index, token, value);\n    };\n\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n        }\n        return node;\n    }\n\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanString() {\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n\n        while (index < length) {\n            ch = advance();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\v';\n                        break;\n\n                    default:\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            // Deprecating unused code. TODO review removal\n                            //if (code !== 0) {\n                            //    octal = true;\n                            //}\n\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                //TODO Review Removal octal = true;\n                                code = code * 8 + '01234567'.indexOf(advance());\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    code = code * 8 + '01234567'.indexOf(advance());\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            utility.throwError('unexpected quote');\n        }\n\n        value = str;\n        return Token.STRING;\n    }\n\n    function scanNumber() {\n        var number, ch;\n\n        number = '';\n        ch = source.charCodeAt(index);\n\n        if (ch !== 0x2E  /* '.' */) {\n            number = advance();\n            ch = source.charCodeAt(index);\n\n            if (number === '0') {\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError('unexpected token');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError('unexpected token');\n                }\n            }\n\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x2E  /* '.' */) {\n            number += advance();\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\n            number += advance();\n\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\n                number += advance();\n            }\n\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while (index < length) {\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n\n\n    function scanTypeName() {\n        var ch, ch2;\n\n        value = advance();\n        while (index < length && isTypeName(source.charCodeAt(index))) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E  /* '.' */) {\n                if ((index + 1) >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C  /* '<' */) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n\n    function next() {\n        var ch;\n\n        previous = index;\n\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n\n        ch = source.charCodeAt(index);\n        switch (ch) {\n        case 0x27:  /* ''' */\n        case 0x22:  /* '\"' */\n            token = scanString();\n            return token;\n\n        case 0x3A:  /* ':' */\n            advance();\n            token = Token.COLON;\n            return token;\n\n        case 0x2C:  /* ',' */\n            advance();\n            token = Token.COMMA;\n            return token;\n\n        case 0x28:  /* '(' */\n            advance();\n            token = Token.LPAREN;\n            return token;\n\n        case 0x29:  /* ')' */\n            advance();\n            token = Token.RPAREN;\n            return token;\n\n        case 0x5B:  /* '[' */\n            advance();\n            token = Token.LBRACK;\n            return token;\n\n        case 0x5D:  /* ']' */\n            advance();\n            token = Token.RBRACK;\n            return token;\n\n        case 0x7B:  /* '{' */\n            advance();\n            token = Token.LBRACE;\n            return token;\n\n        case 0x7D:  /* '}' */\n            advance();\n            token = Token.RBRACE;\n            return token;\n\n        case 0x2E:  /* '.' */\n            if (index + 1 < length) {\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x3C  /* '<' */) {\n                    advance();  // '.'\n                    advance();  // '<'\n                    token = Token.DOT_LT;\n                    return token;\n                }\n\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\n                    advance();  // '.'\n                    advance();  // '.'\n                    advance();  // '.'\n                    token = Token.REST;\n                    return token;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n            }\n            token = Token.ILLEGAL;\n            return token;\n\n        case 0x3C:  /* '<' */\n            advance();\n            token = Token.LT;\n            return token;\n\n        case 0x3E:  /* '>' */\n            advance();\n            token = Token.GT;\n            return token;\n\n        case 0x2A:  /* '*' */\n            advance();\n            token = Token.STAR;\n            return token;\n\n        case 0x7C:  /* '|' */\n            advance();\n            token = Token.PIPE;\n            return token;\n\n        case 0x3F:  /* '?' */\n            advance();\n            token = Token.QUESTION;\n            return token;\n\n        case 0x21:  /* '!' */\n            advance();\n            token = Token.BANG;\n            return token;\n\n        case 0x3D:  /* '=' */\n            advance();\n            token = Token.EQUAL;\n            return token;\n\n        case 0x2D: /* '-' */\n            token = scanNumber();\n            return token;\n\n        default:\n            if (esutils.code.isDecimalDigit(ch)) {\n                token = scanNumber();\n                return token;\n            }\n\n            // type string permits following case,\n            //\n            // namespace.module.MyClass\n            //\n            // this reduced 1 token TK_NAME\n            utility.assert(isTypeName(ch));\n            token = scanTypeName();\n            return token;\n        }\n    }\n\n    function consume(target, text) {\n        utility.assert(token === target, text || 'consumed token not matched');\n        next();\n    }\n\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || 'unexpected token');\n        }\n        next();\n    }\n\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, 'UnionType should start with (');\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while (true) {\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, 'UnionType should end with )');\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, 'ArrayType should start with [');\n        elements = [];\n        while (token !== Token.RBRACK) {\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [restStartIndex, previous]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n\n        utility.throwError('unexpected token');\n    }\n\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [rangeStart, previous]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [rangeStart, previous]);\n    }\n\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n\n        consume(Token.LBRACE, 'RecordType should start with {');\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while (token !== Token.RBRACE) {\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [rangeStart, rangeEnd]);\n    }\n\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n\n        if (token === Token.COLON && (\n                name === 'module' ||\n                name === 'external' ||\n                name === 'event')) {\n            consume(Token.COLON);\n            name += ':' + value;\n            expect(Token.NAME);\n        }\n\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [rangeStart, previous]);\n    }\n\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n\n        elements.push(parseTop());\n        while (token === Token.COMMA) {\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [startIndex, previous]);\n        }\n        return expr;\n    }\n\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, 'ResultType should start with :');\n        if (token === Token.NAME && value === 'void') {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n\n        while (token !== Token.RPAREN) {\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n\n            startIndex = previous;\n\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [nameStartIndex, previous]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [startIndex, previous]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError('unexpected token');\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [restStartIndex, previous]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n        consume(Token.NAME);\n\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME &&\n                    (value === 'this' || value === 'new')) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === 'new';\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n\n        expect(Token.RPAREN);\n\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [startIndex, previous]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType['this'] = thisBinding;\n            if (isNew) {\n                fnType['new'] = true;\n            }\n        }\n        return fnType;\n    }\n\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch (token) {\n        case Token.STAR:\n            consume(Token.STAR);\n            return maybeAddRange({\n                type: Syntax.AllLiteral\n            }, [previous - 1, previous]);\n\n        case Token.LPAREN:\n            return parseUnionType();\n\n        case Token.LBRACK:\n            return parseArrayType();\n\n        case Token.LBRACE:\n            return parseRecordType();\n\n        case Token.NAME:\n            startIndex = index - value.length;\n\n            if (value === 'null') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.NullLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'undefined') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.UndefinedLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'true' || value === 'false') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.BooleanLiteralType,\n                    value: value === 'true'\n                }, [startIndex, previous]);\n            }\n\n            context = Context.save();\n            if (value === 'function') {\n                try {\n                    return parseFunctionType();\n                } catch (e) {\n                    context.restore();\n                }\n            }\n\n            return parseTypeName();\n\n        case Token.STRING:\n            next();\n            return maybeAddRange({\n                type: Syntax.StringLiteralType,\n                value: value\n            }, [previous - value.length - 2, previous]);\n\n        case Token.NUMBER:\n            next();\n            return maybeAddRange({\n                type: Syntax.NumericLiteralType,\n                value: value\n            }, [previous - String(value).length, previous]);\n\n        default:\n            utility.throwError('unexpected token');\n        }\n    }\n\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\n                    token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [rangeStart, previous]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else {\n            rangeStart = previous;\n        }\n\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: 'Array'\n                }, [rangeStart, previous]),\n                applications: [expr]\n            }, [rangeStart, previous]);\n        }\n\n        return expr;\n    }\n\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n\n        elements = [expr];\n        consume(Token.PIPE);\n        while (true) {\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [0, index]);\n    }\n\n    function parseTopParamType() {\n        var expr;\n\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [0, index]);\n        }\n\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [0, index]);\n        }\n\n        return expr;\n    }\n\n    function parseType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTop();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function parseParamType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTopParamType();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n\n        switch (node.type) {\n        case Syntax.NullableLiteral:\n            result = '?';\n            break;\n\n        case Syntax.AllLiteral:\n            result = '*';\n            break;\n\n        case Syntax.NullLiteral:\n            result = 'null';\n            break;\n\n        case Syntax.UndefinedLiteral:\n            result = 'undefined';\n            break;\n\n        case Syntax.VoidLiteral:\n            result = 'void';\n            break;\n\n        case Syntax.UnionType:\n            if (!topLevel) {\n                result = '(';\n            } else {\n                result = '';\n            }\n\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? '|' : ' | ';\n                }\n            }\n\n            if (!topLevel) {\n                result += ')';\n            }\n            break;\n\n        case Syntax.ArrayType:\n            result = '[';\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += ']';\n            break;\n\n        case Syntax.RecordType:\n            result = '{';\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\n                result += stringifyImpl(node.fields[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '}';\n            break;\n\n        case Syntax.FieldType:\n            if (node.value) {\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n            } else {\n                result = node.key;\n            }\n            break;\n\n        case Syntax.FunctionType:\n            result = compact ? 'function(' : 'function (';\n\n            if (node['this']) {\n                if (node['new']) {\n                    result += (compact ? 'new:' : 'new: ');\n                } else {\n                    result += (compact ? 'this:' : 'this: ');\n                }\n\n                result += stringifyImpl(node['this'], compact);\n\n                if (node.params.length !== 0) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                result += stringifyImpl(node.params[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            result += ')';\n\n            if (node.result) {\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n            }\n            break;\n\n        case Syntax.ParameterType:\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n            break;\n\n        case Syntax.RestType:\n            result = '...';\n            if (node.expression) {\n                result += stringifyImpl(node.expression, compact);\n            }\n            break;\n\n        case Syntax.NonNullableType:\n            if (node.prefix) {\n                result = '!' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '!';\n            }\n            break;\n\n        case Syntax.OptionalType:\n            result = stringifyImpl(node.expression, compact) + '=';\n            break;\n\n        case Syntax.NullableType:\n            if (node.prefix) {\n                result = '?' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '?';\n            }\n            break;\n\n        case Syntax.NameExpression:\n            result = node.name;\n            break;\n\n        case Syntax.TypeApplication:\n            result = stringifyImpl(node.expression, compact) + '.<';\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\n                result += stringifyImpl(node.applications[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '>';\n            break;\n\n        case Syntax.StringLiteralType:\n            result = '\"' + node.value + '\"';\n            break;\n\n        case Syntax.NumericLiteralType:\n            result = String(node.value);\n            break;\n\n        case Syntax.BooleanLiteralType:\n            result = String(node.value);\n            break;\n\n        default:\n            utility.throwError('Unknown type ' + node.type);\n        }\n\n        return result;\n    }\n\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}